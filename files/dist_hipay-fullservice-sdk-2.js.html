<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dist/hipay-fullservice-sdk-2.js - hipay-fullservice-sdk-js</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/css/lucid.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
            hipay-fullservice-sdk-js
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.0.3</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/HiPay", "classes/HiPay.Form"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
<div>
    <div id="sidebar">
    <div id="classes">
        <ul id="api-classes" class="nav nav-list">
                <li><a href="../classes/HiPay.html">HiPay</a></li>
                <li><a href="../classes/HiPay.Form.html">HiPay.Form</a></li>
        </ul>
    </div>
    </div>
</div>
        </div>
        <div class="span9">
    <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>dist/hipay-fullservice-sdk-2.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
/*
 * ! https://github.com/davidchambers/Base64.js
 */
;(function () {

    var object = typeof exports != &#x27;undefined&#x27; ? exports : this; // #8: web
    // workers
    var chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;;

    function InvalidCharacterError(message) {
        this.message = message;
    }
    InvalidCharacterError.prototype = new Error;
    InvalidCharacterError.prototype.name = &#x27;InvalidCharacterError&#x27;;

    // encoder
    // [https://gist.github.com/999166] by [https://github.com/nignag]
    object.btoa || (
        object.btoa = function (input) {
            for (
                // initialize result and counter
                var block, charCode, idx = 0, map = chars, output = &#x27;&#x27;;
                // if the next input index does not exist:
                // change the mapping table to &quot;=&quot;
                // check if d has no fractional digits
                input.charAt(idx | 0) || (map = &#x27;=&#x27;, idx % 1);
                // &quot;8 - idx % 1 * 8&quot; generates the sequence 2, 4, 6, 8
                output += map.charAt(63 &amp; block &gt;&gt; 8 - idx % 1 * 8)
            ) {
                charCode = input.charCodeAt(idx += 3/4);
                if (charCode &gt; 0xFF) {
                    throw new InvalidCharacterError(&quot;&#x27;btoa&#x27; failed: The string to be encoded contains characters outside of the Latin1 range.&quot;);
                }
                block = block &lt;&lt; 8 | charCode;
            }
            return output;
        });

    // decoder
    // [https://gist.github.com/1020396] by [https://github.com/atk]
    object.atob || (
        object.atob = function (input) {
            input = input.replace(/=+$/, &#x27;&#x27;)
            if (input.length % 4 == 1) {
                throw new InvalidCharacterError(&quot;&#x27;atob&#x27; failed: The string to be decoded is not correctly encoded.&quot;);
            }
            for (
                // initialize result and counters
                var bc = 0, bs, buffer, idx = 0, output = &#x27;&#x27;;
                // get next character
                buffer = input.charAt(idx++);
                // character found in table? initialize bit storage and add its ascii
                // value;
                ~buffer &amp;&amp; (bs = bc % 4 ? bs * 64 + buffer : buffer,
                    // and if not first of each 4 characters,
                    // convert the first 8 bits to one ascii character
                bc++ % 4) ? output += String.fromCharCode(255 &amp; bs &gt;&gt; (-2 * bc &amp; 6)) : 0
            ) {
                // try to find character in table (0-63, not found =&gt; -1)
                buffer = chars.indexOf(buffer);
            }
            return output;
        });

}());
;
/**
 * Created by jkurc on 28/07/17.
 */
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
    // Detect the &#x60;define&#x60; function exposed by asynchronous module loaders. The
    // strict &#x60;define&#x60; check is necessary for compatibility with &#x60;r.js&#x60;.
    var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

    // A set of types used to distinguish objects from primitives.
    var objectTypes = {
        &quot;function&quot;: true,
        &quot;object&quot;: true
    };

    // Detect the &#x60;exports&#x60; object exposed by CommonJS implementations.
    var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

    // Use the &#x60;global&#x60; object exposed by Node (including Browserify via
    // &#x60;insert-module-globals&#x60;), Narwhal, and Ringo as the default context,
    // and the &#x60;window&#x60; object in browsers. Rhino exports a &#x60;global&#x60; function
    // instead.
    var root = objectTypes[typeof window] &amp;&amp; window || this,
        freeGlobal = freeExports &amp;&amp; objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; typeof global == &quot;object&quot; &amp;&amp; global;

    if (freeGlobal &amp;&amp; (freeGlobal[&quot;global&quot;] === freeGlobal || freeGlobal[&quot;window&quot;] === freeGlobal || freeGlobal[&quot;self&quot;] === freeGlobal)) {
        root = freeGlobal;
    }

    // Public: Initializes JSON 3 using the given &#x60;context&#x60; object, attaching the
    // &#x60;stringify&#x60; and &#x60;parse&#x60; functions to the specified &#x60;exports&#x60; object.
    function runInContext(context, exports) {
        context || (context = root[&quot;Object&quot;]());
        exports || (exports = root[&quot;Object&quot;]());

        // Native constructor aliases.
        var Number = context[&quot;Number&quot;] || root[&quot;Number&quot;],
            String = context[&quot;String&quot;] || root[&quot;String&quot;],
            Object = context[&quot;Object&quot;] || root[&quot;Object&quot;],
            Date = context[&quot;Date&quot;] || root[&quot;Date&quot;],
            SyntaxError = context[&quot;SyntaxError&quot;] || root[&quot;SyntaxError&quot;],
            TypeError = context[&quot;TypeError&quot;] || root[&quot;TypeError&quot;],
            Math = context[&quot;Math&quot;] || root[&quot;Math&quot;],
            nativeJSON = context[&quot;JSON&quot;] || root[&quot;JSON&quot;];

        // Delegate to the native &#x60;stringify&#x60; and &#x60;parse&#x60; implementations.
        if (typeof nativeJSON == &quot;object&quot; &amp;&amp; nativeJSON) {
            exports.stringify = nativeJSON.stringify;
            exports.parse = nativeJSON.parse;
        }

        // Convenience aliases.
        var objectProto = Object.prototype,
            getClass = objectProto.toString,
            isProperty, forEach, undef;

        // Test the &#x60;Date#getUTC*&#x60; methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292);
        try {
            // The &#x60;getUTCFullYear&#x60;, &#x60;Month&#x60;, and &#x60;Date&#x60; methods return nonsensical
            // results for certain dates in Opera &gt;= 10.53.
            isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
                // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
                // but clips the values returned by the date methods to the range of
                // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
                isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}

        // Internal: Determines whether the native &#x60;JSON.stringify&#x60; and &#x60;parse&#x60;
        // implementations are spec-compliant. Based on work by Ken Snyder.
        function has(name) {
            if (has[name] !== undef) {
                // Return cached feature test result.
                return has[name];
            }
            var isSupported;
            if (name == &quot;bug-string-char-index&quot;) {
                // IE &lt;= 7 doesn&#x27;t support accessing string characters using square
                // bracket notation. IE 8 only supports this for primitives.
                isSupported = &quot;a&quot;[0] != &quot;a&quot;;
            } else if (name == &quot;json&quot;) {
                // Indicates whether both &#x60;JSON.stringify&#x60; and &#x60;JSON.parse&#x60; are
                // supported.
                isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
            } else {
                var value, serialized = &#x27;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&#x27;;
                // Test &#x60;JSON.stringify&#x60;.
                if (name == &quot;json-stringify&quot;) {
                    var stringify = exports.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
                    if (stringifySupported) {
                        // A test function object with a custom &#x60;toJSON&#x60; method.
                        (value = function () {
                            return 1;
                        }).toJSON = value;
                        try {
                            stringifySupported =
                                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                                // primitives as object literals.
                                stringify(0) === &quot;0&quot; &amp;&amp;
                                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                                // literals.
                                stringify(new Number()) === &quot;0&quot; &amp;&amp;
                                stringify(new String()) == &#x27;&quot;&quot;&#x27; &amp;&amp;
                                // FF 3.1b1, 2 throw an error if the value is &#x60;null&#x60;, &#x60;undefined&#x60;, or
                                // does not define a canonical JSON representation (this applies to
                                // objects with &#x60;toJSON&#x60; properties as well, *unless* they are nested
                                // within an object or array).
                                stringify(getClass) === undef &amp;&amp;
                                // IE 8 serializes &#x60;undefined&#x60; as &#x60;&quot;undefined&quot;&#x60;. Safari &lt;= 5.1.7 and
                                // FF 3.1b3 pass this test.
                                stringify(undef) === undef &amp;&amp;
                                // Safari &lt;= 5.1.7 and FF 3.1b3 throw &#x60;Error&#x60;s and &#x60;TypeError&#x60;s,
                                // respectively, if the value is omitted entirely.
                                stringify() === undef &amp;&amp;
                                // FF 3.1b1, 2 throw an error if the given value is not a number,
                                // string, array, object, Boolean, or &#x60;null&#x60; literal. This applies to
                                // objects with custom &#x60;toJSON&#x60; methods as well, unless they are nested
                                // inside object or array literals. YUI 3.0.0b1 ignores custom &#x60;toJSON&#x60;
                                // methods entirely.
                                stringify(value) === &quot;1&quot; &amp;&amp;
                                stringify([value]) == &quot;[1]&quot; &amp;&amp;
                                // Prototype &lt;= 1.6.1 serializes &#x60;[undefined]&#x60; as &#x60;&quot;[]&quot;&#x60; instead of
                                // &#x60;&quot;[null]&quot;&#x60;.
                                stringify([undef]) == &quot;[null]&quot; &amp;&amp;
                                // YUI 3.0.0b1 fails to serialize &#x60;null&#x60; literals.
                                stringify(null) == &quot;null&quot; &amp;&amp;
                                // FF 3.1b1, 2 halts serialization if an array contains a function:
                                // &#x60;[1, true, getClass, 1]&#x60; serializes as &quot;[1,true,],&quot;. FF 3.1b3
                                // elides non-JSON values from objects and arrays, unless they
                                // define custom &#x60;toJSON&#x60; methods.
                                stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
                                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                                // where character escape codes are expected (e.g., &#x60;\b&#x60; =&gt; &#x60;\u0008&#x60;).
                                stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
                                // FF 3.1b1 and b2 ignore the &#x60;filter&#x60; and &#x60;width&#x60; arguments.
                                stringify(null, value) === &quot;1&quot; &amp;&amp;
                                stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
                                // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
                                // serialize extended years.
                                stringify(new Date(-8.64e15)) == &#x27;&quot;-271821-04-20T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                // The milliseconds are optional in ES 5, but required in 5.1.
                                stringify(new Date(8.64e15)) == &#x27;&quot;+275760-09-13T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
                                // four-digit years instead of six-digit years. Credits: @Yaffle.
                                stringify(new Date(-621987552e5)) == &#x27;&quot;-000001-01-01T00:00:00.000Z&quot;&#x27; &amp;&amp;
                                // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
                                // values less than 1000. Credits: @Yaffle.
                                stringify(new Date(-1)) == &#x27;&quot;1969-12-31T23:59:59.999Z&quot;&#x27;;
                        } catch (exception) {
                            stringifySupported = false;
                        }
                    }
                    isSupported = stringifySupported;
                }
                // Test &#x60;JSON.parse&#x60;.
                if (name == &quot;json-parse&quot;) {
                    var parse = exports.parse;
                    if (typeof parse == &quot;function&quot;) {
                        try {
                            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                            // Conforming implementations should also coerce the initial argument to
                            // a string prior to parsing.
                            if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
                                // Simple parsing test.
                                value = parse(serialized);
                                var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
                                if (parseSupported) {
                                    try {
                                        // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                                        parseSupported = !parse(&#x27;&quot;\t&quot;&#x27;);
                                    } catch (exception) {}
                                    if (parseSupported) {
                                        try {
                                            // FF 4.0 and 4.0.1 allow leading &#x60;+&#x60; signs and leading
                                            // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                                            // certain octal literals.
                                            parseSupported = parse(&quot;01&quot;) !== 1;
                                        } catch (exception) {}
                                    }
                                    if (parseSupported) {
                                        try {
                                            // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                                            // points. These environments, along with FF 3.1b1 and 2,
                                            // also allow trailing commas in JSON objects and arrays.
                                            parseSupported = parse(&quot;1.&quot;) !== 1;
                                        } catch (exception) {}
                                    }
                                }
                            }
                        } catch (exception) {
                            parseSupported = false;
                        }
                    }
                    isSupported = parseSupported;
                }
            }
            return has[name] = !!isSupported;
        }

        if (!has(&quot;json&quot;)) {
            // Common &#x60;[[Class]]&#x60; name aliases.
            var functionClass = &quot;[object Function]&quot;,
                dateClass = &quot;[object Date]&quot;,
                numberClass = &quot;[object Number]&quot;,
                stringClass = &quot;[object String]&quot;,
                arrayClass = &quot;[object Array]&quot;,
                booleanClass = &quot;[object Boolean]&quot;;

            // Detect incomplete support for accessing string characters by index.
            var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

            // Define additional utility methods if the &#x60;Date&#x60; methods are buggy.
            if (!isExtended) {
                var floor = Math.floor;
                // A mapping between the months of the year and the number of days between
                // January 1st and the first of the respective month.
                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                // Internal: Calculates the number of days between the Unix epoch and the
                // first day of the given month.
                var getDay = function (year, month) {
                    return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                };
            }

            // Internal: Determines if a property is a direct property of the given
            // object. Delegates to the native &#x60;Object#hasOwnProperty&#x60; method.
            if (!(isProperty = objectProto.hasOwnProperty)) {
                isProperty = function (property) {
                    var members = {}, constructor;
                    if ((members.__proto__ = null, members.__proto__ = {
                            // The *proto* property cannot be set multiple times in recent
                            // versions of Firefox and SeaMonkey.
                            &quot;toString&quot;: 1
                        }, members).toString != getClass) {
                        // Safari &lt;= 2.0.3 doesn&#x27;t implement &#x60;Object#hasOwnProperty&#x60;, but
                        // supports the mutable *proto* property.
                        isProperty = function (property) {
                            // Capture and break the object&#x27;s prototype chain (see section 8.6.2
                            // of the ES 5.1 spec). The parenthesized expression prevents an
                            // unsafe transformation by the Closure Compiler.
                            var original = this.__proto__, result = property in (this.__proto__ = null, this);
                            // Restore the original prototype chain.
                            this.__proto__ = original;
                            return result;
                        };
                    } else {
                        // Capture a reference to the top-level &#x60;Object&#x60; constructor.
                        constructor = members.constructor;
                        // Use the &#x60;constructor&#x60; property to simulate &#x60;Object#hasOwnProperty&#x60; in
                        // other environments.
                        isProperty = function (property) {
                            var parent = (this.constructor || constructor).prototype;
                            return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
                        };
                    }
                    members = null;
                    return isProperty.call(this, property);
                };
            }

            // Internal: Normalizes the &#x60;for...in&#x60; iteration algorithm across
            // environments. Each enumerated key is yielded to a &#x60;callback&#x60; function.
            forEach = function (object, callback) {
                var size = 0, Properties, members, property;

                // Tests for bugs in the current environment&#x27;s &#x60;for...in&#x60; algorithm. The
                // &#x60;valueOf&#x60; property inherits the non-enumerable flag from
                // &#x60;Object.prototype&#x60; in older versions of IE, Netscape, and Mozilla.
                (Properties = function () {
                    this.valueOf = 0;
                }).prototype.valueOf = 0;

                // Iterate over a new instance of the &#x60;Properties&#x60; class.
                members = new Properties();
                for (property in members) {
                    // Ignore all properties inherited from &#x60;Object.prototype&#x60;.
                    if (isProperty.call(members, property)) {
                        size++;
                    }
                }
                Properties = members = null;

                // Normalize the iteration algorithm.
                if (!size) {
                    // A list of non-enumerable properties inherited from &#x60;Object.prototype&#x60;.
                    members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
                    // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
                    // properties.
                    forEach = function (object, callback) {
                        var isFunction = getClass.call(object) == functionClass, property, length;
                        var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &quot;function&quot; &amp;&amp; objectTypes[typeof object.hasOwnProperty] &amp;&amp; object.hasOwnProperty || isProperty;
                        for (property in object) {
                            // Gecko &lt;= 1.0 enumerates the &#x60;prototype&#x60; property of functions under
                            // certain conditions; IE does not.
                            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
                                callback(property);
                            }
                        }
                        // Manually invoke the callback for each non-enumerable property.
                        for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
                    };
                } else if (size == 2) {
                    // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
                    forEach = function (object, callback) {
                        // Create a set of iterated properties.
                        var members = {}, isFunction = getClass.call(object) == functionClass, property;
                        for (property in object) {
                            // Store each property name to prevent double enumeration. The
                            // &#x60;prototype&#x60; property of functions is not enumerated due to cross-
                            // environment inconsistencies.
                            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
                                callback(property);
                            }
                        }
                    };
                } else {
                    // No bugs detected; use the standard &#x60;for...in&#x60; algorithm.
                    forEach = function (object, callback) {
                        var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                        for (property in object) {
                            if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
                                callback(property);
                            }
                        }
                        // Manually invoke the callback for the &#x60;constructor&#x60; property due to
                        // cross-environment inconsistencies.
                        if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
                            callback(property);
                        }
                    };
                }
                return forEach(object, callback);
            };

            // Public: Serializes a JavaScript &#x60;value&#x60; as a JSON string. The optional
            // &#x60;filter&#x60; argument may specify either a function that alters how object and
            // array members are serialized, or an array of strings and numbers that
            // indicates which properties should be serialized. The optional &#x60;width&#x60;
            // argument may be either a string or number that specifies the indentation
            // level of the output.
            if (!has(&quot;json-stringify&quot;)) {
                // Internal: A map of control characters and their escaped equivalents.
                var Escapes = {
                    92: &quot;\\\\&quot;,
                    34: &#x27;\\&quot;&#x27;,
                    8: &quot;\\b&quot;,
                    12: &quot;\\f&quot;,
                    10: &quot;\\n&quot;,
                    13: &quot;\\r&quot;,
                    9: &quot;\\t&quot;
                };

                // Internal: Converts &#x60;value&#x60; into a zero-padded string such that its
                // length is at least equal to &#x60;width&#x60;. The &#x60;width&#x60; must be &lt;= 6.
                var leadingZeroes = &quot;000000&quot;;
                var toPaddedString = function (width, value) {
                    // The &#x60;|| 0&#x60; expression is necessary to work around a bug in
                    // Opera &lt;= 7.54u2 where &#x60;0 == -0&#x60;, but &#x60;String(-0) !== &quot;0&quot;&#x60;.
                    return (leadingZeroes + (value || 0)).slice(-width);
                };

                // Internal: Double-quotes a string &#x60;value&#x60;, replacing all ASCII control
                // characters (characters with code unit values between 0 and 31) with
                // their escaped equivalents. This is an implementation of the
                // &#x60;Quote(value)&#x60; operation defined in ES 5.1 section 15.12.3.
                var unicodePrefix = &quot;\\u00&quot;;
                var quote = function (value) {
                    var result = &#x27;&quot;&#x27;, index = 0, length = value.length, useCharIndex = !charIndexBuggy || length &gt; 10;
                    var symbols = useCharIndex &amp;&amp; (charIndexBuggy ? value.split(&quot;&quot;) : value);
                    for (; index &lt; length; index++) {
                        var charCode = value.charCodeAt(index);
                        // If the character is a control character, append its Unicode or
                        // shorthand escape sequence; otherwise, append the character as-is.
                        switch (charCode) {
                            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                            result += Escapes[charCode];
                            break;
                            default:
                                if (charCode &lt; 32) {
                                    result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                                    break;
                                }
                                result += useCharIndex ? symbols[index] : value.charAt(index);
                        }
                    }
                    return result + &#x27;&quot;&#x27;;
                };

                // Internal: Recursively serializes an object. Implements the
                // &#x60;Str(key, holder)&#x60;, &#x60;JO(value)&#x60;, and &#x60;JA(value)&#x60; operations.
                var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
                    var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                    try {
                        // Necessary for host object support.
                        value = object[property];
                    } catch (exception) {}
                    if (typeof value == &quot;object&quot; &amp;&amp; value) {
                        className = getClass.call(value);
                        if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
                            if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
                                // Dates are serialized according to the &#x60;Date#toJSON&#x60; method
                                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                                // for the ISO 8601 date time string format.
                                if (getDay) {
                                    // Manually compute the year, month, date, hours, minutes,
                                    // seconds, and milliseconds if the &#x60;getUTC*&#x60; methods are
                                    // buggy. Adapted from @Yaffle&#x27;s &#x60;date-shim&#x60; project.
                                    date = floor(value / 864e5);
                                    for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                                    for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                                    date = 1 + date - getDay(year, month);
                                    // The &#x60;time&#x60; value specifies the time within the day (see ES
                                    // 5.1 section 15.9.1.2). The formula &#x60;(A % B + B) % B&#x60; is used
                                    // to compute &#x60;A modulo B&#x60;, as the &#x60;%&#x60; operator does not
                                    // correspond to the &#x60;modulo&#x60; operation for negative numbers.
                                    time = (value % 864e5 + 864e5) % 864e5;
                                    // The hours, minutes, seconds, and milliseconds are obtained by
                                    // decomposing the time within the day. See section 15.9.1.10.
                                    hours = floor(time / 36e5) % 24;
                                    minutes = floor(time / 6e4) % 60;
                                    seconds = floor(time / 1e3) % 60;
                                    milliseconds = time % 1e3;
                                } else {
                                    year = value.getUTCFullYear();
                                    month = value.getUTCMonth();
                                    date = value.getUTCDate();
                                    hours = value.getUTCHours();
                                    minutes = value.getUTCMinutes();
                                    seconds = value.getUTCSeconds();
                                    milliseconds = value.getUTCMilliseconds();
                                }
                                // Serialize extended years correctly.
                                value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                                    &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                                    // Months, dates, hours, minutes, and seconds should have two
                                    // digits; milliseconds should have three.
                                    &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                                    // Milliseconds are optional in ES 5.0, but required in 5.1.
                                    &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
                            } else {
                                value = null;
                            }
                        } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
                            // Prototype &lt;= 1.6.1 adds non-standard &#x60;toJSON&#x60; methods to the
                            // &#x60;Number&#x60;, &#x60;String&#x60;, &#x60;Date&#x60;, and &#x60;Array&#x60; prototypes. JSON 3
                            // ignores all &#x60;toJSON&#x60; methods on these objects unless they are
                            // defined directly on an instance.
                            value = value.toJSON(property);
                        }
                    }
                    if (callback) {
                        // If a replacement function was provided, call it to obtain the value
                        // for serialization.
                        value = callback.call(object, property, value);
                    }
                    if (value === null) {
                        return &quot;null&quot;;
                    }
                    className = getClass.call(value);
                    if (className == booleanClass) {
                        // Booleans are represented literally.
                        return &quot;&quot; + value;
                    } else if (className == numberClass) {
                        // JSON numbers must be finite. &#x60;Infinity&#x60; and &#x60;NaN&#x60; are serialized as
                        // &#x60;&quot;null&quot;&#x60;.
                        return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
                    } else if (className == stringClass) {
                        // Strings are double-quoted and escaped.
                        return quote(&quot;&quot; + value);
                    }
                    // Recursively serialize objects and arrays.
                    if (typeof value == &quot;object&quot;) {
                        // Check for cyclic structures. This is a linear search; performance
                        // is inversely proportional to the number of unique nested objects.
                        for (length = stack.length; length--;) {
                            if (stack[length] === value) {
                                // Cyclic structures cannot be serialized by &#x60;JSON.stringify&#x60;.
                                throw TypeError();
                            }
                        }
                        // Add the object to the stack of traversed objects.
                        stack.push(value);
                        results = [];
                        // Save the current indentation level and indent one additional level.
                        prefix = indentation;
                        indentation += whitespace;
                        if (className == arrayClass) {
                            // Recursively serialize array elements.
                            for (index = 0, length = value.length; index &lt; length; index++) {
                                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                results.push(element === undef ? &quot;null&quot; : element);
                            }
                            result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
                        } else {
                            // Recursively serialize object members. Members are selected from
                            // either a user-specified list of property names, or the object
                            // itself.
                            forEach(properties || value, function (property) {
                                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                if (element !== undef) {
                                    // According to ES 5.1 section 15.12.3: &quot;If &#x60;gap&#x60; {whitespace}
                                    // is not the empty string, let &#x60;member&#x60; {quote(property) + &quot;:&quot;}
                                    // be the concatenation of &#x60;member&#x60; and the &#x60;space&#x60; character.&quot;
                                    // The &quot;&#x60;space&#x60; character&quot; refers to the literal space
                                    // character, not the &#x60;space&#x60; {width} argument provided to
                                    // &#x60;JSON.stringify&#x60;.
                                    results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
                                }
                            });
                            result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
                        }
                        // Remove the object from the traversed object stack.
                        stack.pop();
                        return result;
                    }
                };

                // Public: &#x60;JSON.stringify&#x60;. See ES 5.1 section 15.12.3.
                exports.stringify = function (source, filter, width) {
                    var whitespace, callback, properties, className;
                    if (objectTypes[typeof filter] &amp;&amp; filter) {
                        if ((className = getClass.call(filter)) == functionClass) {
                            callback = filter;
                        } else if (className == arrayClass) {
                            // Convert the property names array into a makeshift set.
                            properties = {};
                            for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
                        }
                    }
                    if (width) {
                        if ((className = getClass.call(width)) == numberClass) {
                            // Convert the &#x60;width&#x60; to an integer and create a string containing
                            // &#x60;width&#x60; number of space characters.
                            if ((width -= width % 1) &gt; 0) {
                                for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
                            }
                        } else if (className == stringClass) {
                            whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
                        }
                    }
                    // Opera &lt;= 7.54u2 discards the values associated with empty string keys
                    // (&#x60;&quot;&quot;&#x60;) only if they are used directly within an object member list
                    // (e.g., &#x60;!(&quot;&quot; in { &quot;&quot;: 1})&#x60;).
                    return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
                };
            }

            // Public: Parses a JSON source string.
            if (!has(&quot;json-parse&quot;)) {
                var fromCharCode = String.fromCharCode;

                // Internal: A map of escaped control characters and their unescaped
                // equivalents.
                var Unescapes = {
                    92: &quot;\\&quot;,
                    34: &#x27;&quot;&#x27;,
                    47: &quot;/&quot;,
                    98: &quot;\b&quot;,
                    116: &quot;\t&quot;,
                    110: &quot;\n&quot;,
                    102: &quot;\f&quot;,
                    114: &quot;\r&quot;
                };

                // Internal: Stores the parser state.
                var Index, Source;

                // Internal: Resets the parser state and throws a &#x60;SyntaxError&#x60;.
                var abort = function () {
                    Index = Source = null;
                    throw SyntaxError();
                };

                // Internal: Returns the next token, or &#x60;&quot;$&quot;&#x60; if the parser has reached
                // the end of the source string. A token may be a string, number, &#x60;null&#x60;
                // literal, or Boolean literal.
                var lex = function () {
                    var source = Source, length = source.length, value, begin, position, isSigned, charCode;
                    while (Index &lt; length) {
                        charCode = source.charCodeAt(Index);
                        switch (charCode) {
                            case 9: case 10: case 13: case 32:
                            // Skip whitespace tokens, including tabs, carriage returns, line
                            // feeds, and space characters.
                            Index++;
                            break;
                            case 123: case 125: case 91: case 93: case 58: case 44:
                            // Parse a punctuator token (&#x60;{&#x60;, &#x60;}&#x60;, &#x60;[&#x60;, &#x60;]&#x60;, &#x60;:&#x60;, or &#x60;,&#x60;) at
                            // the current position.
                            value = charIndexBuggy ? source.charAt(Index) : source[Index];
                            Index++;
                            return value;
                            case 34:
                                // &#x60;&quot;&#x60; delimits a JSON string; advance to the next character and
                                // begin parsing the string. String tokens are prefixed with the
                                // sentinel &#x60;@&#x60; character to distinguish them from punctuators and
                                // end-of-string tokens.
                                for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                                    charCode = source.charCodeAt(Index);
                                    if (charCode &lt; 32) {
                                        // Unescaped ASCII control characters (those with a code unit
                                        // less than the space character) are not permitted.
                                        abort();
                                    } else if (charCode == 92) {
                                        // A reverse solidus (&#x60;\&#x60;) marks the beginning of an escaped
                                        // control character (including &#x60;&quot;&#x60;, &#x60;\&#x60;, and &#x60;/&#x60;) or Unicode
                                        // escape sequence.
                                        charCode = source.charCodeAt(++Index);
                                        switch (charCode) {
                                            case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                                            // Revive escaped control characters.
                                            value += Unescapes[charCode];
                                            Index++;
                                            break;
                                            case 117:
                                                // &#x60;\u&#x60; marks the beginning of a Unicode escape sequence.
                                                // Advance to the first character and validate the
                                                // four-digit code point.
                                                begin = ++Index;
                                                for (position = Index + 4; Index &lt; position; Index++) {
                                                    charCode = source.charCodeAt(Index);
                                                    // A valid sequence comprises four hexdigits (case-
                                                    // insensitive) that form a single hexadecimal value.
                                                    if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                                                        // Invalid Unicode escape sequence.
                                                        abort();
                                                    }
                                                }
                                                // Revive the escaped character.
                                                value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                                                break;
                                            default:
                                                // Invalid escape sequence.
                                                abort();
                                        }
                                    } else {
                                        if (charCode == 34) {
                                            // An unescaped double-quote character marks the end of the
                                            // string.
                                            break;
                                        }
                                        charCode = source.charCodeAt(Index);
                                        begin = Index;
                                        // Optimize for the common case where a string is valid.
                                        while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                                            charCode = source.charCodeAt(++Index);
                                        }
                                        // Append the string as-is.
                                        value += source.slice(begin, Index);
                                    }
                                }
                                if (source.charCodeAt(Index) == 34) {
                                    // Advance to the next character and return the revived string.
                                    Index++;
                                    return value;
                                }
                                // Unterminated string.
                                abort();
                            default:
                                // Parse numbers and literals.
                                begin = Index;
                                // Advance past the negative sign, if one is specified.
                                if (charCode == 45) {
                                    isSigned = true;
                                    charCode = source.charCodeAt(++Index);
                                }
                                // Parse an integer or floating-point value.
                                if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                                    // Leading zeroes are interpreted as octal literals.
                                    if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                                        // Illegal octal literal.
                                        abort();
                                    }
                                    isSigned = false;
                                    // Parse the integer component.
                                    for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                                    // Floats cannot contain a leading decimal point; however, this
                                    // case is already accounted for by the parser.
                                    if (source.charCodeAt(Index) == 46) {
                                        position = ++Index;
                                        // Parse the decimal component.
                                        for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                                        if (position == Index) {
                                            // Illegal trailing decimal.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Parse exponents. The &#x60;e&#x60; denoting the exponent is
                                    // case-insensitive.
                                    charCode = source.charCodeAt(Index);
                                    if (charCode == 101 || charCode == 69) {
                                        charCode = source.charCodeAt(++Index);
                                        // Skip past the sign following the exponent, if one is
                                        // specified.
                                        if (charCode == 43 || charCode == 45) {
                                            Index++;
                                        }
                                        // Parse the exponential component.
                                        for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                                        if (position == Index) {
                                            // Illegal empty exponent.
                                            abort();
                                        }
                                        Index = position;
                                    }
                                    // Coerce the parsed value to a JavaScript number.
                                    return +source.slice(begin, Index);
                                }
                                // A negative sign may only precede numbers.
                                if (isSigned) {
                                    abort();
                                }
                                // &#x60;true&#x60;, &#x60;false&#x60;, and &#x60;null&#x60; literals.
                                if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                                    Index += 4;
                                    return true;
                                } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                                    Index += 5;
                                    return false;
                                } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                                    Index += 4;
                                    return null;
                                }
                                // Unrecognized token.
                                abort();
                        }
                    }
                    // Return the sentinel &#x60;$&#x60; character if the parser has reached the end
                    // of the source string.
                    return &quot;$&quot;;
                };

                // Internal: Parses a JSON &#x60;value&#x60; token.
                var get = function (value) {
                    var results, hasMembers;
                    if (value == &quot;$&quot;) {
                        // Unexpected end of input.
                        abort();
                    }
                    if (typeof value == &quot;string&quot;) {
                        if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
                            // Remove the sentinel &#x60;@&#x60; character.
                            return value.slice(1);
                        }
                        // Parse object and array literals.
                        if (value == &quot;[&quot;) {
                            // Parses a JSON array, returning a new JavaScript array.
                            results = [];
                            for (;; hasMembers || (hasMembers = true)) {
                                value = lex();
                                // A closing square bracket marks the end of the array literal.
                                if (value == &quot;]&quot;) {
                                    break;
                                }
                                // If the array literal contains elements, the current token
                                // should be a comma separating the previous element from the
                                // next.
                                if (hasMembers) {
                                    if (value == &quot;,&quot;) {
                                        value = lex();
                                        if (value == &quot;]&quot;) {
                                            // Unexpected trailing &#x60;,&#x60; in array literal.
                                            abort();
                                        }
                                    } else {
                                        // A &#x60;,&#x60; must separate each array element.
                                        abort();
                                    }
                                }
                                // Elisions and leading commas are not permitted.
                                if (value == &quot;,&quot;) {
                                    abort();
                                }
                                results.push(get(value));
                            }
                            return results;
                        } else if (value == &quot;{&quot;) {
                            // Parses a JSON object, returning a new JavaScript object.
                            results = {};
                            for (;; hasMembers || (hasMembers = true)) {
                                value = lex();
                                // A closing curly brace marks the end of the object literal.
                                if (value == &quot;}&quot;) {
                                    break;
                                }
                                // If the object literal contains members, the current token
                                // should be a comma separator.
                                if (hasMembers) {
                                    if (value == &quot;,&quot;) {
                                        value = lex();
                                        if (value == &quot;}&quot;) {
                                            // Unexpected trailing &#x60;,&#x60; in object literal.
                                            abort();
                                        }
                                    } else {
                                        // A &#x60;,&#x60; must separate each object member.
                                        abort();
                                    }
                                }
                                // Leading commas are not permitted, object property names must be
                                // double-quoted strings, and a &#x60;:&#x60; must separate each property
                                // name and value.
                                if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                                    abort();
                                }
                                results[value.slice(1)] = get(lex());
                            }
                            return results;
                        }
                        // Unexpected token encountered.
                        abort();
                    }
                    return value;
                };

                // Internal: Updates a traversed object member.
                var update = function (source, property, callback) {
                    var element = walk(source, property, callback);
                    if (element === undef) {
                        delete source[property];
                    } else {
                        source[property] = element;
                    }
                };

                // Internal: Recursively traverses a parsed JSON object, invoking the
                // &#x60;callback&#x60; function for each value. This is an implementation of the
                // &#x60;Walk(holder, name)&#x60; operation defined in ES 5.1 section 15.12.2.
                var walk = function (source, property, callback) {
                    var value = source[property], length;
                    if (typeof value == &quot;object&quot; &amp;&amp; value) {
                        // &#x60;forEach&#x60; can&#x27;t be used to traverse an array in Opera &lt;= 8.54
                        // because its &#x60;Object#hasOwnProperty&#x60; implementation returns &#x60;false&#x60;
                        // for array indices (e.g., &#x60;![1, 2, 3].hasOwnProperty(&quot;0&quot;)&#x60;).
                        if (getClass.call(value) == arrayClass) {
                            for (length = value.length; length--;) {
                                update(value, length, callback);
                            }
                        } else {
                            forEach(value, function (property) {
                                update(value, property, callback);
                            });
                        }
                    }
                    return callback.call(source, property, value);
                };

                // Public: &#x60;JSON.parse&#x60;. See ES 5.1 section 15.12.2.
                exports.parse = function (source, callback) {
                    var result, value;
                    Index = 0;
                    Source = &quot;&quot; + source;
                    result = get(lex());
                    // If a JSON string contains multiple tokens, it is invalid.
                    if (lex() != &quot;$&quot;) {
                        abort();
                    }
                    // Reset the parser state.
                    Index = Source = null;
                    return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
                };
            }
        }

        exports[&quot;runInContext&quot;] = runInContext;
        return exports;
    }

    if (freeExports &amp;&amp; !isLoader) {
        // Export for CommonJS environments.
        runInContext(root, freeExports);
    } else {
        // Export for web browsers and JavaScript engines.
        var nativeJSON = root.JSON,
            previousJSON = root[&quot;JSON3&quot;],
            isRestored = false;

        var JSON3 = runInContext(root, (root[&quot;JSON3&quot;] = {
            // Public: Restores the original value of the global &#x60;JSON&#x60; object and
            // returns a reference to the &#x60;JSON3&#x60; object.
            &quot;noConflict&quot;: function () {
                if (!isRestored) {
                    isRestored = true;
                    root.JSON = nativeJSON;
                    root[&quot;JSON3&quot;] = previousJSON;
                    nativeJSON = previousJSON = null;
                }
                return JSON3;
            }
        }));

        root.JSON = {
            &quot;parse&quot;: JSON3.parse,
            &quot;stringify&quot;: JSON3.stringify
        };
    }

    // Export for asynchronous module loaders.
    if (isLoader) {
        define(function () {
            return JSON3;
        });
    }
}).call(this);
;
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.0
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(e){if(&quot;object&quot;==typeof exports&amp;&amp;&quot;undefined&quot;!=typeof module)module.exports=e();else if(&quot;function&quot;==typeof define&amp;&amp;define.amd)define([],e);else{var f;&quot;undefined&quot;!=typeof window?f=window:&quot;undefined&quot;!=typeof global?f=global:&quot;undefined&quot;!=typeof self&amp;&amp;(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==&quot;function&quot;&amp;&amp;_dereq_;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==&quot;function&quot;&amp;&amp;_dereq_;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_(&quot;./schedule&quot;);
var Queue = _dereq_(&quot;./queue&quot;);
var util = _dereq_(&quot;./util&quot;);

function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule = schedule;
}

Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};

Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};

Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues;
};


Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write(&quot;Fatal &quot; + (e instanceof Error ? e.stack : e) +
            &quot;\n&quot;);
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== &quot;undefined&quot;) {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error(&quot;No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype._drainQueue = function(queue) {
    while (queue.length() &gt; 0) {
        var fn = queue.shift();
        if (typeof fn !== &quot;function&quot;) {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = Async;
module.exports.firstLineError = firstLineError;

},{&quot;./queue&quot;:26,&quot;./schedule&quot;:29,&quot;./util&quot;:36}],3:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
var calledBind = false;
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (((this._bitField &amp; 50397184) === 0)) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    if (!calledBind) {
        calledBind = true;
        Promise.prototype._propagateFrom = debug.propagateFromFunction();
        Promise.prototype._boundValue = debug.boundValueFunction();
    }
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();
    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, undefined, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, undefined, ret, context);
        ret._setOnCancel(maybePromise);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField &amp; (~2097152);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField &amp; 2097152) === 2097152;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};
};

},{}],4:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var old;
if (typeof Promise !== &quot;undefined&quot;) old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_(&quot;./promise&quot;)();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{&quot;./promise&quot;:22}],5:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[&quot; size&quot;] = getterCache[&quot; size&quot;] = 0;
}

module.exports = function(Promise) {
var util = _dereq_(&quot;./util&quot;);
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function(&quot;ensureMethod&quot;, &quot;                                    \n\
        return function(obj) {                                               \n\
            &#x27;use strict&#x27;                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, &#x27;methodName&#x27;);                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        &quot;.replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function(&quot;obj&quot;, &quot;                                             \n\
        &#x27;use strict&#x27;;                                                        \n\
        return obj.propertyName;                                             \n\
        &quot;.replace(&quot;propertyName&quot;, propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== &quot;function&quot;) {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[&quot; size&quot;]++;
        if (cache[&quot; size&quot;] &gt; 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i &lt; 256; ++i) delete cache[keys[i]];
            cache[&quot; size&quot;] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== &quot;function&quot;) {
        var message = &quot;Object &quot; + util.classString(obj) + &quot; has no method &#x27;&quot; +
            util.toString(methodName) + &quot;&#x27;&quot;;
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var args = [].slice.call(arguments, 1);;
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index &lt; 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === &quot;number&quot;);
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{&quot;./util&quot;:36}],6:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, PromiseArray, apiRejection, debug) {
var util = _dereq_(&quot;./util&quot;);
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

Promise.prototype[&quot;break&quot;] = Promise.prototype.cancel = function() {
    if (!debug.cancellation()) return this._warn(&quot;cancellation is disabled&quot;);

    var promise = this;
    var child = promise;
    while (promise._isCancellable()) {
        if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
                child._followee().cancel();
            } else {
                child._cancelBranched();
            }
            break;
        }

        var parent = promise._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
                promise._followee().cancel();
            } else {
                promise._cancelBranched();
            }
            break;
        } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
        }
    }
};

Promise.prototype._branchHasCancelled = function() {
    this._branchesRemainingToCancel--;
};

Promise.prototype._enoughBranchesHaveCancelled = function() {
    return this._branchesRemainingToCancel === undefined ||
           this._branchesRemainingToCancel &lt;= 0;
};

Promise.prototype._cancelBy = function(canceller) {
    if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
    } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
        }
    }
    return false;
};

Promise.prototype._cancelBranched = function() {
    if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
    }
};

Promise.prototype._cancel = function() {
    if (!this._isCancellable()) return;
    this._setCancelled();
    async.invoke(this._cancelPromises, this, undefined);
};

Promise.prototype._cancelPromises = function() {
    if (this._length() &gt; 0) this._settlePromises();
};

Promise.prototype._unsetOnCancel = function() {
    this._onCancelField = undefined;
};

Promise.prototype._isCancellable = function() {
    return this.isPending() &amp;&amp; !this._isCancelled();
};

Promise.prototype.isCancellable = function() {
    return this.isPending() &amp;&amp; !this.isCancelled();
};

Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
    if (util.isArray(onCancelCallback)) {
        for (var i = 0; i &lt; onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
    } else if (onCancelCallback !== undefined) {
        if (typeof onCancelCallback === &quot;function&quot;) {
            if (!internalOnly) {
                var e = tryCatch(onCancelCallback).call(this._boundValue());
                if (e === errorObj) {
                    this._attachExtraTrace(e.e);
                    async.throwLater(e.e);
                }
            }
        } else {
            onCancelCallback._resultCancelled(this);
        }
    }
};

Promise.prototype._invokeOnCancel = function() {
    var onCancelCallback = this._onCancel();
    this._unsetOnCancel();
    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
};

Promise.prototype._invokeInternalOnCancel = function() {
    if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
    }
};

Promise.prototype._resultCancelled = function() {
    this.cancel();
};

};

},{&quot;./util&quot;:36}],7:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(NEXT_FILTER) {
var util = _dereq_(&quot;./util&quot;);
var getKeys = _dereq_(&quot;./es5&quot;).keys;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function catchFilter(instances, cb, promise) {
    return function(e) {
        var boundTo = promise._boundValue();
        predicateLoop: for (var i = 0; i &lt; instances.length; ++i) {
            var item = instances[i];

            if (item === Error ||
                (item != null &amp;&amp; item.prototype instanceof Error)) {
                if (e instanceof item) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (typeof item === &quot;function&quot;) {
                var matchesPredicate = tryCatch(item).call(boundTo, e);
                if (matchesPredicate === errorObj) {
                    return matchesPredicate;
                } else if (matchesPredicate) {
                    return tryCatch(cb).call(boundTo, e);
                }
            } else if (util.isObject(e)) {
                var keys = getKeys(item);
                for (var j = 0; j &lt; keys.length; ++j) {
                    var key = keys[j];
                    if (item[key] != e[key]) {
                        continue predicateLoop;
                    }
                }
                return tryCatch(cb).call(boundTo, e);
            }
        }
        return NEXT_FILTER;
    };
}

return catchFilter;
};

},{&quot;./es5&quot;:13,&quot;./util&quot;:36}],8:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise) {
var longStackTraces = false;
var contextStack = [];

Promise.prototype._promiseCreated = function() {};
Promise.prototype._pushContext = function() {};
Promise.prototype._popContext = function() {return null;};
Promise._peekContext = Promise.prototype._peekContext = function() {};

function Context() {
    this._trace = new Context.CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (this._trace !== undefined) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (this._trace !== undefined) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
    }
    return null;
};

function createContext() {
    if (longStackTraces) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex &gt;= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}
Context.CapturedTrace = null;
Context.create = createContext;
Context.deactivateLongStackTraces = function() {};
Context.activateLongStackTraces = function() {
    var Promise_pushContext = Promise.prototype._pushContext;
    var Promise_popContext = Promise.prototype._popContext;
    var Promise_PeekContext = Promise._peekContext;
    var Promise_peekContext = Promise.prototype._peekContext;
    var Promise_promiseCreated = Promise.prototype._promiseCreated;
    Context.deactivateLongStackTraces = function() {
        Promise.prototype._pushContext = Promise_pushContext;
        Promise.prototype._popContext = Promise_popContext;
        Promise._peekContext = Promise_PeekContext;
        Promise.prototype._peekContext = Promise_peekContext;
        Promise.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
    };
    longStackTraces = true;
    Promise.prototype._pushContext = Context.prototype._pushContext;
    Promise.prototype._popContext = Context.prototype._popContext;
    Promise._peekContext = Promise.prototype._peekContext = peekContext;
    Promise.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx &amp;&amp; ctx._promiseCreated == null) ctx._promiseCreated = this;
    };
};
return Context;
};

},{}],9:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, Context) {
var getDomain = Promise._getDomain;
var async = Promise._async;
var Warning = _dereq_(&quot;./errors&quot;).Warning;
var util = _dereq_(&quot;./util&quot;);
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
var parseLinePattern = /[\/&lt;\(](.+?):(\d+):(\d+)\)?\s*$/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var printWarning;
var debugging = !!(util.env(&quot;BLUEBIRD_DEBUG&quot;) != 0 &amp;&amp;
                        (true ||
                         util.env(&quot;BLUEBIRD_DEBUG&quot;) ||
                         util.env(&quot;NODE_ENV&quot;) === &quot;development&quot;));

var warnings = !!(util.env(&quot;BLUEBIRD_WARNINGS&quot;) != 0 &amp;&amp;
    (debugging || util.env(&quot;BLUEBIRD_WARNINGS&quot;)));

var longStackTraces = !!(util.env(&quot;BLUEBIRD_LONG_STACK_TRACES&quot;) != 0 &amp;&amp;
    (debugging || util.env(&quot;BLUEBIRD_LONG_STACK_TRACES&quot;)));

var wForgottenReturn = util.env(&quot;BLUEBIRD_W_FORGOTTEN_RETURN&quot;) != 0 &amp;&amp;
    (warnings || !!util.env(&quot;BLUEBIRD_W_FORGOTTEN_RETURN&quot;));

Promise.prototype.suppressUnhandledRejections = function() {
    var target = this._target();
    target._bitField = ((target._bitField &amp; (~1048576)) |
                      524288);
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField &amp; 524288) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    fireRejectionEvent(&quot;rejectionHandled&quot;,
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._setReturnedNonUndefined = function() {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._returnedNonUndefined = function() {
    return (this._bitField &amp; 268435456) !== 0;
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(&quot;unhandledRejection&quot;,
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 262144;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField &amp; (~262144);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField &amp; 262144) &gt; 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 1048576;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField &amp; (~1048576);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField &amp; 1048576) &gt; 0;
};

Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
    return warn(message, shouldUseOwnTrace, promise || this);
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === &quot;function&quot; ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === &quot;function&quot; ? (domain === null ?
                                            fn : util.domainBind(domain, fn))
                                 : undefined;
};

var disableLongStackTraces = function() {};
Promise.longStackTraces = function () {
    if (async.haveItemsQueued() &amp;&amp; !config.longStackTraces) {
        throw new Error(&quot;cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    if (!config.longStackTraces &amp;&amp; longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
            if (async.haveItemsQueued() &amp;&amp; !config.longStackTraces) {
                throw new Error(&quot;cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
            }
            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config.longStackTraces = false;
        };
        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return config.longStackTraces &amp;&amp; longStackTracesIsSupported();
};

var fireDomEvent = (function() {
    try {
        if (typeof CustomEvent === &quot;function&quot;) {
            var event = new CustomEvent(&quot;CustomEvent&quot;);
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new CustomEvent(name.toLowerCase(), {
                    detail: event,
                    cancelable: true
                });
                return !util.global.dispatchEvent(domEvent);
            };
        } else if (typeof Event === &quot;function&quot;) {
            var event = new Event(&quot;CustomEvent&quot;);
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = new Event(name.toLowerCase(), {
                    cancelable: true
                });
                domEvent.detail = event;
                return !util.global.dispatchEvent(domEvent);
            };
        } else {
            var event = document.createEvent(&quot;CustomEvent&quot;);
            event.initCustomEvent(&quot;testingtheevent&quot;, false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event) {
                var domEvent = document.createEvent(&quot;CustomEvent&quot;);
                domEvent.initCustomEvent(name.toLowerCase(), false, true,
                    event);
                return !util.global.dispatchEvent(domEvent);
            };
        }
    } catch (e) {}
    return function() {
        return false;
    };
})();

var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function() {
            return process.emit.apply(process, arguments);
        };
    } else {
        if (!util.global) {
            return function() {
                return false;
            };
        }
        return function(name) {
            var methodName = &quot;on&quot; + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
        };
    }
})();

function generatePromiseLifecycleEventObject(name, promise) {
    return {promise: promise};
}

var eventToObjectGenerator = {
    promiseCreated: generatePromiseLifecycleEventObject,
    promiseFulfilled: generatePromiseLifecycleEventObject,
    promiseRejected: generatePromiseLifecycleEventObject,
    promiseResolved: generatePromiseLifecycleEventObject,
    promiseCancelled: generatePromiseLifecycleEventObject,
    promiseChained: function(name, promise, child) {
        return {promise: promise, child: child};
    },
    warning: function(name, warning) {
        return {warning: warning};
    },
    unhandledRejection: function (name, reason, promise) {
        return {reason: reason, promise: promise};
    },
    rejectionHandled: generatePromiseLifecycleEventObject
};

var activeFireEvent = function (name) {
    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
    } catch (e) {
        async.throwLater(e);
        globalEventFired = true;
    }

    var domEventFired = false;
    try {
        domEventFired = fireDomEvent(name,
                    eventToObjectGenerator[name].apply(null, arguments));
    } catch (e) {
        async.throwLater(e);
        domEventFired = true;
    }

    return domEventFired || globalEventFired;
};

Promise.config = function(opts) {
    opts = Object(opts);
    if (&quot;longStackTraces&quot; in opts) {
        if (opts.longStackTraces) {
            Promise.longStackTraces();
        } else if (!opts.longStackTraces &amp;&amp; Promise.hasLongStackTraces()) {
            disableLongStackTraces();
        }
    }
    if (&quot;warnings&quot; in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;

        if (util.isObject(warningsOption)) {
            if (&quot;wForgottenReturn&quot; in warningsOption) {
                wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
        }
    }
    if (&quot;cancellation&quot; in opts &amp;&amp; opts.cancellation &amp;&amp; !config.cancellation) {
        if (async.haveItemsQueued()) {
            throw new Error(
                &quot;cannot enable cancellation after promises are in use&quot;);
        }
        Promise.prototype._clearCancellationData =
            cancellationClearCancellationData;
        Promise.prototype._propagateFrom = cancellationPropagateFrom;
        Promise.prototype._onCancel = cancellationOnCancel;
        Promise.prototype._setOnCancel = cancellationSetOnCancel;
        Promise.prototype._attachCancellationCallback =
            cancellationAttachCancellationCallback;
        Promise.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
    }
    if (&quot;monitoring&quot; in opts) {
        if (opts.monitoring &amp;&amp; !config.monitoring) {
            config.monitoring = true;
            Promise.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring &amp;&amp; config.monitoring) {
            config.monitoring = false;
            Promise.prototype._fireEvent = defaultFireEvent;
        }
    }
    return Promise;
};

function defaultFireEvent() { return false; }

Promise.prototype._fireEvent = defaultFireEvent;
Promise.prototype._execute = function(executor, resolve, reject) {
    try {
        executor(resolve, reject);
    } catch (e) {
        return e;
    }
};
Promise.prototype._onCancel = function () {};
Promise.prototype._setOnCancel = function (handler) { ; };
Promise.prototype._attachCancellationCallback = function(onCancel) {
    ;
};
Promise.prototype._captureStackTrace = function () {};
Promise.prototype._attachExtraTrace = function () {};
Promise.prototype._clearCancellationData = function() {};
Promise.prototype._propagateFrom = function (parent, flags) {
    ;
    ;
};

function cancellationExecute(executor, resolve, reject) {
    var promise = this;
    try {
        executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== &quot;function&quot;) {
                throw new TypeError(&quot;onCancel must be a function, got: &quot; +
                                    util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
        });
    } catch (e) {
        return e;
    }
}

function cancellationAttachCancellationCallback(onCancel) {
    if (!this._isCancellable()) return this;

    var previousOnCancel = this._onCancel();
    if (previousOnCancel !== undefined) {
        if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
        } else {
            this._setOnCancel([previousOnCancel, onCancel]);
        }
    } else {
        this._setOnCancel(onCancel);
    }
}

function cancellationOnCancel() {
    return this._onCancelField;
}

function cancellationSetOnCancel(onCancel) {
    this._onCancelField = onCancel;
}

function cancellationClearCancellationData() {
    this._cancellationParent = undefined;
    this._onCancelField = undefined;
}

function cancellationPropagateFrom(parent, flags) {
    if ((flags &amp; 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === undefined) {
            branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
    }
    if ((flags &amp; 2) !== 0 &amp;&amp; parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}

function bindingPropagateFrom(parent, flags) {
    if ((flags &amp; 2) !== 0 &amp;&amp; parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
}
var propagateFromFunction = bindingPropagateFrom;

function boundValueFunction() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
}

function longStackTracesCaptureStackTrace() {
    this._trace = new CapturedTrace(this._peekContext());
}

function longStackTracesAttachExtraTrace(error, ignoreSelf) {
    if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(error, &quot;stack&quot;,
                parsed.message + &quot;\n&quot; + parsed.stack.join(&quot;\n&quot;));
            util.notEnumerableProp(error, &quot;__stackCleaned__&quot;, true);
        }
    }
}

function checkForgottenReturns(returnValue, promiseCreated, name, promise,
                               parent) {
    if (returnValue === undefined &amp;&amp; promiseCreated !== null &amp;&amp;
        wForgottenReturn) {
        if (parent !== undefined &amp;&amp; parent._returnedNonUndefined()) return;
        if ((promise._bitField &amp; 65535) === 0) return;

        if (name) name = name + &quot; &quot;;
        var handlerLine = &quot;&quot;;
        var creatorLine = &quot;&quot;;
        if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split(&quot;\n&quot;);
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i &gt;= 0; --i) {
                var line = stack[i];
                if (!nodeFramePattern.test(line)) {
                    var lineMatches = line.match(parseLinePattern);
                    if (lineMatches) {
                        handlerLine  = &quot;at &quot; + lineMatches[1] +
                            &quot;:&quot; + lineMatches[2] + &quot;:&quot; + lineMatches[3] + &quot; &quot;;
                    }
                    break;
                }
            }

            if (stack.length &gt; 0) {
                var firstUserLine = stack[0];
                for (var i = 0; i &lt; traceLines.length; ++i) {

                    if (traceLines[i] === firstUserLine) {
                        if (i &gt; 0) {
                            creatorLine = &quot;\n&quot; + traceLines[i - 1];
                        }
                        break;
                    }
                }

            }
        }
        var msg = &quot;a promise was created in a &quot; + name +
            &quot;handler &quot; + handlerLine + &quot;but was not returned from it, &quot; +
            &quot;see http://goo.gl/rRqMUw&quot; +
            creatorLine;
        promise._warn(msg, true, promiseCreated);
    }
}

function deprecated(name, replacement) {
    var message = name +
        &quot; is deprecated and will be removed in a future version.&quot;;
    if (replacement) message += &quot; Use &quot; + replacement + &quot; instead.&quot;;
    return warn(message);
}

function warn(message, shouldUseOwnTrace, promise) {
    if (!config.warnings) return;
    var warning = new Warning(message);
    var ctx;
    if (shouldUseOwnTrace) {
        promise._attachExtraTrace(warning);
    } else if (config.longStackTraces &amp;&amp; (ctx = Promise._peekContext())) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + &quot;\n&quot; + parsed.stack.join(&quot;\n&quot;);
    }

    if (!activeFireEvent(&quot;warning&quot;, warning)) {
        formatAndLogError(warning, &quot;&quot;, true);
    }
}

function reconstructStack(message, stacks) {
    for (var i = 0; i &lt; stacks.length - 1; ++i) {
        stacks[i].push(&quot;From previous event:&quot;);
        stacks[i] = stacks[i].join(&quot;\n&quot;);
    }
    if (i &lt; stacks.length) {
        stacks[i] = stacks[i].join(&quot;\n&quot;);
    }
    return message + &quot;\n&quot; + stacks.join(&quot;\n&quot;);
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i &lt; stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 &lt; stacks.length) &amp;&amp; stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i &lt; stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j &gt;= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j &gt;= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i &lt; stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = &quot;    (No stack trace)&quot; === line ||
            stackFramePattern.test(line);
        var isInternalFrame = isTraceLine &amp;&amp; shouldIgnore(line);
        if (isTraceLine &amp;&amp; !isInternalFrame) {
            if (indentStackFrames &amp;&amp; line.charAt(0) !== &quot; &quot;) {
                line = &quot;    &quot; + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, &quot;&quot;).split(&quot;\n&quot;);
    for (var i = 0; i &lt; stack.length; ++i) {
        var line = stack[i];
        if (&quot;    (No stack trace)&quot; === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i &gt; 0 &amp;&amp; error.name != &quot;SyntaxError&quot;) {
        stack = stack.slice(i);
    }
    return stack;
}

function parseStackAndMessage(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === &quot;string&quot; &amp;&amp; stack.length &gt; 0
                ? stackFramesAsArray(error) : [&quot;    (No stack trace)&quot;];
    return {
        message: message,
        stack: error.name == &quot;SyntaxError&quot; ? stack : cleanStack(stack)
    };
}

function formatAndLogError(error, title, isSoft) {
    if (typeof console !== &quot;undefined&quot;) {
        var message;
        if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof printWarning === &quot;function&quot;) {
            printWarning(message, isSoft);
        } else if (typeof console.log === &quot;function&quot; ||
            typeof console.log === &quot;object&quot;) {
            console.log(message);
        }
    }
}

function fireRejectionEvent(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === &quot;function&quot;) {
            localEventFired = true;
            if (name === &quot;rejectionHandled&quot;) {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    if (name === &quot;unhandledRejection&quot;) {
        if (!activeFireEvent(name, reason, promise) &amp;&amp; !localEventFired) {
            formatAndLogError(reason, &quot;Unhandled rejection &quot;);
        }
    } else {
        activeFireEvent(name, promise);
    }
}

function formatNonError(obj) {
    var str;
    if (typeof obj === &quot;function&quot;) {
        str = &quot;[function &quot; +
            (obj.name || &quot;anonymous&quot;) +
            &quot;]&quot;;
    } else {
        str = obj &amp;&amp; typeof obj.toString === &quot;function&quot;
            ? obj.toString() : util.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = &quot;(empty array)&quot;;
        }
    }
    return (&quot;(&lt;&quot; + snip(str) + &quot;&gt;, no stack trace)&quot;);
}

function snip(str) {
    var maxChars = 41;
    if (str.length &lt; maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + &quot;...&quot;;
}

function longStackTracesIsSupported() {
    return typeof captureStackTrace === &quot;function&quot;;
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/&lt;\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}

function setBounds(firstLineError, lastLineError) {
    if (!longStackTracesIsSupported()) return;
    var firstStackLines = firstLineError.stack.split(&quot;\n&quot;);
    var lastStackLines = lastLineError.stack.split(&quot;\n&quot;);
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i &lt; firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i &lt; lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex &lt; 0 || lastIndex &lt; 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex &gt;= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &amp;&amp;
                (firstIndex &lt;= info.line &amp;&amp; info.line &lt;= lastIndex)) {
                return true;
            }
        }
        return false;
    };
}

function CapturedTrace(parent) {
    this._parent = parent;
    this._promisesCreated = 0;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length &gt; 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);
Context.CapturedTrace = CapturedTrace;

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length &lt; 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i &gt;= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i &lt; length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined &amp;&amp; index !== i) {
            if (index &gt; 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i &gt; 0 ? nodes[i - 1] : this;

            if (index &lt; length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j &gt;= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split(&quot;\n&quot;)));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, &quot;stack&quot;, reconstructStack(message, stacks));
    util.notEnumerableProp(error, &quot;__stackCleaned__&quot;, true);
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === &quot;string&quot;) return stack;

        if (error.name !== undefined &amp;&amp;
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === &quot;number&quot; &amp;&amp;
        typeof Error.captureStackTrace === &quot;function&quot;) {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === &quot;string&quot; &amp;&amp;
        err.stack.split(&quot;\n&quot;)[0].indexOf(&quot;stackDetection@&quot;) &gt;= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = (&quot;stack&quot; in e);
    }
    if (!(&quot;stack&quot; in err) &amp;&amp; hasStackAfterThrow &amp;&amp;
        typeof Error.stackTraceLimit === &quot;number&quot;) {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit += 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit -= 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === &quot;string&quot;) return stack;

        if ((typeof error === &quot;object&quot; ||
            typeof error === &quot;function&quot;) &amp;&amp;
            error.name !== undefined &amp;&amp;
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

if (typeof console !== &quot;undefined&quot; &amp;&amp; typeof console.warn !== &quot;undefined&quot;) {
    printWarning = function (message) {
        console.warn(message);
    };
    if (util.isNode &amp;&amp; process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
            var color = isSoft ? &quot;\u001b[33m&quot; : &quot;\u001b[31m&quot;;
            console.warn(color + message + &quot;\u001b[0m\n&quot;);
        };
    } else if (!util.isNode &amp;&amp; typeof (new Error().stack) === &quot;string&quot;) {
        printWarning = function(message, isSoft) {
            console.warn(&quot;%c&quot; + message,
                        isSoft ? &quot;color: darkorange&quot; : &quot;color: red&quot;);
        };
    }
}

var config = {
    warnings: warnings,
    longStackTraces: false,
    cancellation: false,
    monitoring: false
};

if (longStackTraces) Promise.longStackTraces();

return {
    longStackTraces: function() {
        return config.longStackTraces;
    },
    warnings: function() {
        return config.warnings;
    },
    cancellation: function() {
        return config.cancellation;
    },
    monitoring: function() {
        return config.monitoring;
    },
    propagateFromFunction: function() {
        return propagateFromFunction;
    },
    boundValueFunction: function() {
        return boundValueFunction;
    },
    checkForgottenReturns: checkForgottenReturns,
    setBounds: setBounds,
    warn: warn,
    deprecated: deprecated,
    CapturedTrace: CapturedTrace,
    fireDomEvent: fireDomEvent,
    fireGlobalEvent: fireGlobalEvent
};
};

},{&quot;./errors&quot;:12,&quot;./util&quot;:36}],10:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise) {
function returner() {
    return this.value;
}
function thrower() {
    throw this.reason;
}

Promise.prototype[&quot;return&quot;] =
Promise.prototype.thenReturn = function (value) {
    if (value instanceof Promise) value.suppressUnhandledRejections();
    return this._then(
        returner, undefined, undefined, {value: value}, undefined);
};

Promise.prototype[&quot;throw&quot;] =
Promise.prototype.thenThrow = function (reason) {
    return this._then(
        thrower, undefined, undefined, {reason: reason}, undefined);
};

Promise.prototype.catchThrow = function (reason) {
    if (arguments.length &lt;= 1) {
        return this._then(
            undefined, thrower, undefined, {reason: reason}, undefined);
    } else {
        var _reason = arguments[1];
        var handler = function() {throw _reason;};
        return this.caught(reason, handler);
    }
};

Promise.prototype.catchReturn = function (value) {
    if (arguments.length &lt;= 1) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(
            undefined, returner, undefined, {value: value}, undefined);
    } else {
        var _value = arguments[1];
        if (_value instanceof Promise) _value.suppressUnhandledRejections();
        var handler = function() {return _value;};
        return this.caught(value, handler);
    }
};
};

},{}],11:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;
var PromiseAll = Promise.all;

function promiseAllThis() {
    return PromiseAll(this);
}

function PromiseMapSeries(promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
}

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, this, undefined);
};

Promise.prototype.mapSeries = function (fn) {
    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, INTERNAL, 0)
              ._then(promiseAllThis, undefined, undefined, promises, undefined);
};

Promise.mapSeries = PromiseMapSeries;
};


},{}],12:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var es5 = _dereq_(&quot;./es5&quot;);
var Objectfreeze = es5.freeze;
var util = _dereq_(&quot;./util&quot;);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, &quot;message&quot;,
            typeof message === &quot;string&quot; ? message : defaultMessage);
        notEnumerableProp(this, &quot;name&quot;, nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError(&quot;Warning&quot;, &quot;warning&quot;);
var CancellationError = subError(&quot;CancellationError&quot;, &quot;cancellation error&quot;);
var TimeoutError = subError(&quot;TimeoutError&quot;, &quot;timeout error&quot;);
var AggregateError = subError(&quot;AggregateError&quot;, &quot;aggregate error&quot;);
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError(&quot;TypeError&quot;, &quot;type error&quot;);
    _RangeError = subError(&quot;RangeError&quot;, &quot;range error&quot;);
}

var methods = (&quot;join pop push shift unshift slice filter forEach some &quot; +
    &quot;every map indexOf lastIndexOf reduce reduceRight sort reverse&quot;).split(&quot; &quot;);

for (var i = 0; i &lt; methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === &quot;function&quot;) {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, &quot;length&quot;, {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype[&quot;isOperational&quot;] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(&quot; &quot;);
    var ret = &quot;\n&quot; + indent + &quot;AggregateError of:&quot; + &quot;\n&quot;;
    level++;
    indent = Array(level * 4 + 1).join(&quot; &quot;);
    for (var i = 0; i &lt; this.length; ++i) {
        var str = this[i] === this ? &quot;[Circular AggregateError]&quot; : this[i] + &quot;&quot;;
        var lines = str.split(&quot;\n&quot;);
        for (var j = 0; j &lt; lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join(&quot;\n&quot;);
        ret += str + &quot;\n&quot;;
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, &quot;name&quot;, &quot;OperationalError&quot;);
    notEnumerableProp(this, &quot;message&quot;, message);
    this.cause = message;
    this[&quot;isOperational&quot;] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, &quot;message&quot;, message.message);
        notEnumerableProp(this, &quot;stack&quot;, message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error[&quot;__BluebirdErrorTypes__&quot;];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, &quot;__BluebirdErrorTypes__&quot;, {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{&quot;./es5&quot;:13,&quot;./util&quot;:36}],13:[function(_dereq_,module,exports){
var isES5 = (function(){
    &quot;use strict&quot;;
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === &quot;[object Array]&quot;;
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],14:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],15:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {
var util = _dereq_(&quot;./util&quot;);
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;
var catchFilter = _dereq_(&quot;./catch_filter&quot;)(NEXT_FILTER);

function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length &gt; 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret === NEXT_FILTER) {
            return ret;
        } else if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise._isCancelled()) {
                        var reason =
                            new CancellationError(&quot;late cancellation observer&quot;);
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== &quot;function&quot;) return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
Promise.prototype[&quot;finally&quot;] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};


Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

Promise.prototype.tapCatch = function (handlerOrPredicate) {
    var len = arguments.length;
    if(len === 1) {
        return this._passThrough(handlerOrPredicate,
                                 1,
                                 undefined,
                                 finallyHandler);
    } else {
         var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i &lt; len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(new TypeError(
                    &quot;tapCatch statement predicate: &quot;
                    + &quot;expecting an object but got &quot; + util.classString(item)
                ));
            }
        }
        catchInstances.length = j;
        var handler = arguments[i];
        return this._passThrough(catchFilter(catchInstances, handler, this),
                                 1,
                                 undefined,
                                 finallyHandler);
    }

};

return PassThroughHandlerContext;
};

},{&quot;./catch_filter&quot;:7,&quot;./util&quot;:36}],16:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise,
                          Proxyable,
                          debug) {
var errors = _dereq_(&quot;./errors&quot;);
var TypeError = errors.TypeError;
var util = _dereq_(&quot;./util&quot;);
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i &lt; yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    if (debug.cancellation()) {
        var internal = new Promise(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
        this._promise = internal.lastly(function() {
            return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
    } else {
        var promise = this._promise = new Promise(INTERNAL);
        promise._captureStackTrace();
    }
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === &quot;function&quot;
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
    this._yieldedPromise = null;
    this._cancellationPhase = false;
}
util.inherits(PromiseSpawn, Proxyable);

PromiseSpawn.prototype._isResolved = function() {
    return this._promise === null;
};

PromiseSpawn.prototype._cleanup = function() {
    this._promise = this._generator = null;
    if (debug.cancellation() &amp;&amp; this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
    }
};

PromiseSpawn.prototype._promiseCancelled = function() {
    if (this._isResolved()) return;
    var implementsReturn = typeof this._generator[&quot;return&quot;] !== &quot;undefined&quot;;

    var result;
    if (!implementsReturn) {
        var reason = new Promise.CancellationError(
            &quot;generator .return() sentinel&quot;);
        Promise.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator[&quot;throw&quot;]).call(this._generator,
                                                         reason);
        this._promise._popContext();
    } else {
        this._promise._pushContext();
        result = tryCatch(this._generator[&quot;return&quot;]).call(this._generator,
                                                          undefined);
        this._promise._popContext();
    }
    this._cancellationPhase = true;
    this._yieldedPromise = null;
    this._continue(result);
};

PromiseSpawn.prototype._promiseFulfilled = function(value) {
    this._yieldedPromise = null;
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._promiseRejected = function(reason) {
    this._yieldedPromise = null;
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator[&quot;throw&quot;])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._resultCancelled = function() {
    if (this._yieldedPromise instanceof Promise) {
        var promise = this._yieldedPromise;
        this._yieldedPromise = null;
        promise.cancel();
    }
};

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._promiseFulfilled(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    var promise = this._promise;
    if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._rejectCallback(result.e, false);
        }
    }

    var value = result.value;
    if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
            return promise.cancel();
        } else {
            return promise._resolveCallback(value);
        }
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._promiseRejected(
                    new TypeError(
                        &quot;A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a&quot;.replace(&quot;%s&quot;, String(value)) +
                        &quot;From coroutine:\u000a&quot; +
                        this._stack.split(&quot;\n&quot;).slice(1, -7).join(&quot;\n&quot;)
                    )
                );
                return;
            }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        ;
        if (((bitField &amp; 50397184) === 0)) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
        } else if (((bitField &amp; 33554432) !== 0)) {
            Promise._async.invoke(
                this._promiseFulfilled, this, maybePromise._value()
            );
        } else if (((bitField &amp; 16777216) !== 0)) {
            Promise._async.invoke(
                this._promiseRejected, this, maybePromise._reason()
            );
        } else {
            this._promiseCancelled();
        }
    }
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== &quot;function&quot;) {
        throw new TypeError(&quot;generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(undefined);
        return ret;
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== &quot;function&quot;) {
        throw new TypeError(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    debug.deprecated(&quot;Promise.spawn()&quot;, &quot;Promise.coroutine()&quot;);
    if (typeof generatorFunction !== &quot;function&quot;) {
        return apiRejection(&quot;generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{&quot;./errors&quot;:12,&quot;./util&quot;:36}],17:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
         getDomain) {
var util = _dereq_(&quot;./util&quot;);
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function(&quot;value&quot;, &quot;holder&quot;, &quot;                             \n\
            &#x27;use strict&#x27;;                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            &quot;.replace(/Index/g, i));
    };

    var promiseSetter = function(i) {
        return new Function(&quot;promise&quot;, &quot;holder&quot;, &quot;                           \n\
            &#x27;use strict&#x27;;                                                    \n\
            holder.pIndex = promise;                                         \n\
            &quot;.replace(/Index/g, i));
    };

    var generateHolderClass = function(total) {
        var props = new Array(total);
        for (var i = 0; i &lt; props.length; ++i) {
            props[i] = &quot;this.p&quot; + (i+1);
        }
        var assignment = props.join(&quot; = &quot;) + &quot; = null;&quot;;
        var cancellationCode= &quot;var promise;\n&quot; + props.map(function(prop) {
            return &quot;                                                         \n\
                promise = &quot; + prop + &quot;;                                      \n\
                if (promise instanceof Promise) {                            \n\
                    promise.cancel();                                        \n\
                }                                                            \n\
            &quot;;
        }).join(&quot;\n&quot;);
        var passedArguments = props.join(&quot;, &quot;);
        var name = &quot;Holder$&quot; + total;


        var code = &quot;return function(tryCatch, errorObj, Promise, async) {    \n\
            &#x27;use strict&#x27;;                                                    \n\
            function [TheName](fn) {                                         \n\
                [TheProperties]                                              \n\
                this.fn = fn;                                                \n\
                this.asyncNeeded = true;                                     \n\
                this.now = 0;                                                \n\
            }                                                                \n\
                                                                             \n\
            [TheName].prototype._callFunction = function(promise) {          \n\
                promise._pushContext();                                      \n\
                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
                promise._popContext();                                       \n\
                if (ret === errorObj) {                                      \n\
                    promise._rejectCallback(ret.e, false);                   \n\
                } else {                                                     \n\
                    promise._resolveCallback(ret);                           \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype.checkFulfillment = function(promise) {       \n\
                var now = ++this.now;                                        \n\
                if (now === [TheTotal]) {                                    \n\
                    if (this.asyncNeeded) {                                  \n\
                        async.invoke(this._callFunction, this, promise);     \n\
                    } else {                                                 \n\
                        this._callFunction(promise);                         \n\
                    }                                                        \n\
                                                                             \n\
                }                                                            \n\
            };                                                               \n\
                                                                             \n\
            [TheName].prototype._resultCancelled = function() {              \n\
                [CancellationCode]                                           \n\
            };                                                               \n\
                                                                             \n\
            return [TheName];                                                \n\
        }(tryCatch, errorObj, Promise, async);                               \n\
        &quot;;

        code = code.replace(/\[TheName\]/g, name)
            .replace(/\[TheTotal\]/g, total)
            .replace(/\[ThePassedArguments\]/g, passedArguments)
            .replace(/\[TheProperties\]/g, assignment)
            .replace(/\[CancellationCode\]/g, cancellationCode);

        return new Function(&quot;tryCatch&quot;, &quot;errorObj&quot;, &quot;Promise&quot;, &quot;async&quot;, code)
                           (tryCatch, errorObj, Promise, async);
    };

    var holderClasses = [];
    var thenCallbacks = [];
    var promiseSetters = [];

    for (var i = 0; i &lt; 8; ++i) {
        holderClasses.push(generateHolderClass(i + 1));
        thenCallbacks.push(thenCallback(i + 1));
        promiseSetters.push(promiseSetter(i + 1));
    }

    reject = function (reason) {
        this._reject(reason);
    };
}}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last &gt; 0 &amp;&amp; typeof arguments[last] === &quot;function&quot;) {
        fn = arguments[last];
        if (!true) {
            if (last &lt;= 8 &amp;&amp; canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var HolderClass = holderClasses[last - 1];
                var holder = new HolderClass(fn);
                var callbacks = thenCallbacks;

                for (var i = 0; i &lt; last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        var bitField = maybePromise._bitField;
                        ;
                        if (((bitField &amp; 50397184) === 0)) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                            promiseSetters[i](maybePromise, holder);
                            holder.asyncNeeded = false;
                        } else if (((bitField &amp; 33554432) !== 0)) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else if (((bitField &amp; 16777216) !== 0)) {
                            ret._reject(maybePromise._reason());
                        } else {
                            ret._cancel();
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }

                if (!ret._isFateSealed()) {
                    if (holder.asyncNeeded) {
                        var domain = getDomain();
                        if (domain !== null) {
                            holder.fn = util.domainBind(domain, holder.fn);
                        }
                    }
                    ret._setAsyncGuaranteed();
                    ret._setOnCancel(holder);
                }
                return ret;
            }
        }
    }
    var args = [].slice.call(arguments);;
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{&quot;./util&quot;:36}],18:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_(&quot;./util&quot;);
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var async = Promise._async;

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : util.domainBind(domain, fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = [];
    async.invoke(this._asyncInit, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._asyncInit = function() {
    this._init$(undefined, -2);
};

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;

    if (index &lt; 0) {
        index = (index * -1) - 1;
        values[index] = value;
        if (limit &gt;= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
        }
    } else {
        if (limit &gt;= 1 &amp;&amp; this._inFlight &gt;= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var promise = this._promise;
        var callback = this._callback;
        var receiver = promise._boundValue();
        promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
            ret,
            promiseCreated,
            preservedValues !== null ? &quot;Promise.filter&quot; : &quot;Promise.map&quot;,
            promise
        );
        if (ret === errorObj) {
            this._reject(ret.e);
            return true;
        }

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if (((bitField &amp; 50397184) === 0)) {
                if (limit &gt;= 1) this._inFlight++;
                values[index] = maybePromise;
                maybePromise._proxy(this, (index + 1) * -1);
                return false;
            } else if (((bitField &amp; 33554432) !== 0)) {
                ret = maybePromise._value();
            } else if (((bitField &amp; 16777216) !== 0)) {
                this._reject(maybePromise._reason());
                return true;
            } else {
                this._cancel();
                return true;
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved &gt;= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }
        return true;
    }
    return false;
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length &gt; 0 &amp;&amp; this._inFlight &lt; limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i &lt; len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    if (typeof fn !== &quot;function&quot;) {
        return apiRejection(&quot;expecting a function but got &quot; + util.classString(fn));
    }

    var limit = 0;
    if (options !== undefined) {
        if (typeof options === &quot;object&quot; &amp;&amp; options !== null) {
            if (typeof options.concurrency !== &quot;number&quot;) {
                return Promise.reject(
                    new TypeError(&quot;&#x27;concurrency&#x27; must be a number but it is &quot; +
                                    util.classString(options.concurrency)));
            }
            limit = options.concurrency;
        } else {
            return Promise.reject(new TypeError(
                            &quot;options argument must be an object but it is &quot; +
                             util.classString(options)));
        }
    }
    limit = typeof limit === &quot;number&quot; &amp;&amp;
        isFinite(limit) &amp;&amp; limit &gt;= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
}

Promise.prototype.map = function (fn, options) {
    return map(this, fn, options, null);
};

Promise.map = function (promises, fn, options, _filter) {
    return map(promises, fn, options, _filter);
};


};

},{&quot;./util&quot;:36}],19:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
var util = _dereq_(&quot;./util&quot;);
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== &quot;function&quot;) {
        throw new Promise.TypeError(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
            value, promiseCreated, &quot;Promise.method&quot;, ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise[&quot;try&quot;] = function (fn) {
    if (typeof fn !== &quot;function&quot;) {
        return apiRejection(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value;
    if (arguments.length &gt; 1) {
        debug.deprecated(&quot;calling Promise.try with more than 1 argument&quot;);
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
                                  : tryCatch(fn).call(ctx, arg);
    } else {
        value = tryCatch(fn)();
    }
    var promiseCreated = ret._popContext();
    debug.checkForgottenReturns(
        value, promiseCreated, &quot;Promise.try&quot;, ret);
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{&quot;./util&quot;:36}],20:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var util = _dereq_(&quot;./util&quot;);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_(&quot;./errors&quot;);
var OperationalError = errors.OperationalError;
var es5 = _dereq_(&quot;./es5&quot;);

function isUntypedError(obj) {
    return obj instanceof Error &amp;&amp;
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i &lt; keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var args = [].slice.call(arguments, 1);;
            promise._fulfill(args);
        }
        promise = null;
    };
}

module.exports = nodebackForPromise;

},{&quot;./errors&quot;:12,&quot;./es5&quot;:13,&quot;./util&quot;:36}],21:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise) {
var util = _dereq_(&quot;./util&quot;);
var async = Promise._async;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var newReason = new Error(reason + &quot;&quot;);
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
                                                                     options) {
    if (typeof nodeback == &quot;function&quot;) {
        var adapter = successAdapter;
        if (options !== undefined &amp;&amp; Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{&quot;./util&quot;:36}],22:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError(&quot;circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
};
var reflectHandler = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
function Proxyable() {}
var UNDEFINED_BINDING = {};
var util = _dereq_(&quot;./util&quot;);

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, &quot;_getDomain&quot;, getDomain);

var es5 = _dereq_(&quot;./es5&quot;);
var Async = _dereq_(&quot;./async&quot;);
var async = new Async();
es5.defineProperty(Promise, &quot;_async&quot;, {value: async});
var errors = _dereq_(&quot;./errors&quot;);
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
var CancellationError = Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {};
var tryConvertToPromise = _dereq_(&quot;./thenables&quot;)(Promise, INTERNAL);
var PromiseArray =
    _dereq_(&quot;./promise_array&quot;)(Promise, INTERNAL,
                               tryConvertToPromise, apiRejection, Proxyable);
var Context = _dereq_(&quot;./context&quot;)(Promise);
 /*jshint unused:false*/
var createContext = Context.create;
var debug = _dereq_(&quot;./debuggability&quot;)(Promise, Context);
var CapturedTrace = debug.CapturedTrace;
var PassThroughHandlerContext =
    _dereq_(&quot;./finally&quot;)(Promise, tryConvertToPromise, NEXT_FILTER);
var catchFilter = _dereq_(&quot;./catch_filter&quot;)(NEXT_FILTER);
var nodebackForPromise = _dereq_(&quot;./nodeback&quot;);
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function check(self, executor) {
    if (self == null || self.constructor !== Promise) {
        throw new TypeError(&quot;the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    if (typeof executor !== &quot;function&quot;) {
        throw new TypeError(&quot;expecting a function but got &quot; + util.classString(executor));
    }

}

function Promise(executor) {
    if (executor !== INTERNAL) {
        check(this, executor);
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._resolveFromExecutor(executor);
    this._promiseCreated();
    this._fireEvent(&quot;promiseCreated&quot;, this);
}

Promise.prototype.toString = function () {
    return &quot;[object Promise]&quot;;
};

Promise.prototype.caught = Promise.prototype[&quot;catch&quot;] = function (fn) {
    var len = arguments.length;
    if (len &gt; 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i &lt; len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
                catchInstances[j++] = item;
            } else {
                return apiRejection(&quot;Catch statement predicate: &quot; +
                    &quot;expecting an object but got &quot; + util.classString(item));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        return this.then(undefined, catchFilter(catchInstances, fn, this));
    }
    return this.then(undefined, fn);
};

Promise.prototype.reflect = function () {
    return this._then(reflectHandler,
        reflectHandler, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject) {
    if (debug.warnings() &amp;&amp; arguments.length &gt; 0 &amp;&amp;
        typeof didFulfill !== &quot;function&quot; &amp;&amp;
        typeof didReject !== &quot;function&quot;) {
        var msg = &quot;.then() only accepts functions but was passed: &quot; +
                util.classString(didFulfill);
        if (arguments.length &gt; 1) {
            msg += &quot;, &quot; + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, undefined, undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject) {
    var promise =
        this._then(didFulfill, didReject, undefined, undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (fn) {
    if (typeof fn !== &quot;function&quot;) {
        return apiRejection(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    if (arguments.length &gt; 0) {
        this._warn(&quot;.all() was passed arguments but it does not take any&quot;);
    }
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.getNewLibraryCopy = module.exports;

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = Promise.fromCallback = function(fn) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    var multiArgs = arguments.length &gt; 1 ? !!Object(arguments[1]).multiArgs
                                         : false;
    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true);
    }
    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._setFulfilled();
        ret._rejectionHandler0 = obj;
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== &quot;function&quot;) {
        throw new TypeError(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    return async.setScheduler(fn);
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    _,    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
    var target = this._target();
    var bitField = target._bitField;

    if (!haveInternalData) {
        promise._propagateFrom(this, 3);
        promise._captureStackTrace();
        if (receiver === undefined &amp;&amp;
            ((this._bitField &amp; 2097152) !== 0)) {
            if (!((bitField &amp; 50397184) === 0)) {
                receiver = this._boundValue();
            } else {
                receiver = target === this ? undefined : this._boundTo;
            }
        }
        this._fireEvent(&quot;promiseChained&quot;, this, promise);
    }

    var domain = getDomain();
    if (!((bitField &amp; 50397184) === 0)) {
        var handler, value, settler = target._settlePromiseCtx;
        if (((bitField &amp; 33554432) !== 0)) {
            value = target._rejectionHandler0;
            handler = didFulfill;
        } else if (((bitField &amp; 16777216) !== 0)) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
        } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError(&quot;late cancellation observer&quot;);
            target._attachExtraTrace(value);
            handler = didReject;
        }

        async.invoke(settler, target, {
            handler: domain === null ? handler
                : (typeof handler === &quot;function&quot; &amp;&amp;
                    util.domainBind(domain, handler)),
            promise: promise,
            receiver: receiver,
            value: value
        });
    } else {
        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
    }

    return promise;
};

Promise.prototype._length = function () {
    return this._bitField &amp; 65535;
};

Promise.prototype._isFateSealed = function () {
    return (this._bitField &amp; 117506048) !== 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField &amp; 67108864) === 67108864;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField &amp; -65536) |
        (len &amp; 65535);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 33554432;
    this._fireEvent(&quot;promiseFulfilled&quot;, this);
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 16777216;
    this._fireEvent(&quot;promiseRejected&quot;, this);
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 67108864;
    this._fireEvent(&quot;promiseResolved&quot;, this);
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._isFinal = function () {
    return (this._bitField &amp; 4194304) &gt; 0;
};

Promise.prototype._unsetCancelled = function() {
    this._bitField = this._bitField &amp; (~65536);
};

Promise.prototype._setCancelled = function() {
    this._bitField = this._bitField | 65536;
    this._fireEvent(&quot;promiseCancelled&quot;, this);
};

Promise.prototype._setWillBeCancelled = function() {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._setAsyncGuaranteed = function() {
    if (async.hasCustomScheduler()) return;
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0 ? this._receiver0 : this[
            index * 4 - 4 + 3];
    if (ret === UNDEFINED_BINDING) {
        return undefined;
    } else if (ret === undefined &amp;&amp; this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return this[
            index * 4 - 4 + 2];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return this[
            index * 4 - 4 + 1];
};

Promise.prototype._boundValue = function() {};

Promise.prototype._migrateCallback0 = function (follower) {
    var bitField = follower._bitField;
    var fulfill = follower._fulfillmentHandler0;
    var reject = follower._rejectionHandler0;
    var promise = follower._promise0;
    var receiver = follower._receiverAt(0);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._migrateCallbackAt = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (receiver === undefined) receiver = UNDEFINED_BINDING;
    this._addCallbacks(fulfill, reject, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index &gt;= 65535 - 4) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        this._receiver0 = receiver;
        if (typeof fulfill === &quot;function&quot;) {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === &quot;function&quot;) {
            this._rejectionHandler0 =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    } else {
        var base = index * 4 - 4;
        this[base + 2] = promise;
        this[base + 3] = receiver;
        if (typeof fulfill === &quot;function&quot;) {
            this[base + 0] =
                domain === null ? fulfill : util.domainBind(domain, fulfill);
        }
        if (typeof reject === &quot;function&quot;) {
            this[base + 1] =
                domain === null ? reject : util.domainBind(domain, reject);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._proxy = function (proxyable, arg) {
    this._addCallbacks(undefined, undefined, arg, proxyable, null);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (((this._bitField &amp; 117506048) !== 0)) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    if (shouldBind) this._propagateFrom(maybePromise, 2);

    var promise = maybePromise._target();

    if (promise === this) {
        this._reject(makeSelfResolutionError());
        return;
    }

    var bitField = promise._bitField;
    if (((bitField &amp; 50397184) === 0)) {
        var len = this._length();
        if (len &gt; 0) promise._migrateCallback0(this);
        for (var i = 1; i &lt; len; ++i) {
            promise._migrateCallbackAt(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (((bitField &amp; 33554432) !== 0)) {
        this._fulfill(promise._value());
    } else if (((bitField &amp; 16777216) !== 0)) {
        this._reject(promise._reason());
    } else {
        var reason = new CancellationError(&quot;late cancellation observer&quot;);
        promise._attachExtraTrace(reason);
        this._reject(reason);
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, ignoreNonErrorWarnings) {
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    if (!hasStack &amp;&amp; !ignoreNonErrorWarnings &amp;&amp; debug.warnings()) {
        var message = &quot;a promise was rejected with a non-error: &quot; +
            util.classString(reason);
        this._warn(message, true);
    }
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason);
};

Promise.prototype._resolveFromExecutor = function (executor) {
    if (executor === INTERNAL) return;
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = this._execute(executor, function(value) {
        promise._resolveCallback(value);
    }, function (reason) {
        promise._rejectCallback(reason, synchronous);
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined) {
        promise._rejectCallback(r, true);
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    var bitField = promise._bitField;
    if (((bitField &amp; 65536) !== 0)) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY) {
        if (!value || typeof value.length !== &quot;number&quot;) {
            x = errorObj;
            x.e = new TypeError(&quot;cannot .spread() a non-array: &quot; +
                                    util.classString(value));
        } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
        }
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    var promiseCreated = promise._popContext();
    bitField = promise._bitField;
    if (((bitField &amp; 65536) !== 0)) return;

    if (x === NEXT_FILTER) {
        promise._reject(value);
    } else if (x === errorObj) {
        promise._rejectCallback(x.e, false);
    } else {
        debug.checkForgottenReturns(x, promiseCreated, &quot;&quot;,  promise, this);
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
    var isPromise = promise instanceof Promise;
    var bitField = this._bitField;
    var asyncGuaranteed = ((bitField &amp; 134217728) !== 0);
    if (((bitField &amp; 65536) !== 0)) {
        if (isPromise) promise._invokeInternalOnCancel();

        if (receiver instanceof PassThroughHandlerContext &amp;&amp;
            receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
                promise._reject(errorObj.e);
            }
        } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
        } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
        } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
        } else {
            receiver.cancel();
        }
    } else if (typeof handler === &quot;function&quot;) {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof Proxyable) {
        if (!receiver._isResolved()) {
            if (((bitField &amp; 33554432) !== 0)) {
                receiver._promiseFulfilled(value, promise);
            } else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (asyncGuaranteed) promise._setAsyncGuaranteed();
        if (((bitField &amp; 33554432) !== 0)) {
            promise._fulfill(value);
        } else {
            promise._reject(value);
        }
    }
};

Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
    var handler = ctx.handler;
    var promise = ctx.promise;
    var receiver = ctx.receiver;
    var value = ctx.value;
    if (typeof handler === &quot;function&quot;) {
        if (!(promise instanceof Promise)) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (promise instanceof Promise) {
        promise._reject(value);
    }
};

Promise.prototype._settlePromiseCtx = function(ctx) {
    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
};

Promise.prototype._settlePromise0 = function(handler, value, bitField) {
    var promise = this._promise0;
    var receiver = this._receiverAt(0);
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settlePromise(promise, handler, receiver, value);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    var base = index * 4 - 4;
    this[base + 2] =
    this[base + 3] =
    this[base + 0] =
    this[base + 1] = undefined;
};

Promise.prototype._fulfill = function (value) {
    var bitField = this._bitField;
    if (((bitField &amp; 117506048) &gt;&gt;&gt; 16)) return;
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._reject(err);
    }
    this._setFulfilled();
    this._rejectionHandler0 = value;

    if ((bitField &amp; 65535) &gt; 0) {
        if (((bitField &amp; 134217728) !== 0)) {
            this._settlePromises();
        } else {
            async.settlePromises(this);
        }
    }
};

Promise.prototype._reject = function (reason) {
    var bitField = this._bitField;
    if (((bitField &amp; 117506048) &gt;&gt;&gt; 16)) return;
    this._setRejected();
    this._fulfillmentHandler0 = reason;

    if (this._isFinal()) {
        return async.fatalError(reason, util.isNode);
    }

    if ((bitField &amp; 65535) &gt; 0) {
        async.settlePromises(this);
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._fulfillPromises = function (len, value) {
    for (var i = 1; i &lt; len; i++) {
        var handler = this._fulfillmentHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, value);
    }
};

Promise.prototype._rejectPromises = function (len, reason) {
    for (var i = 1; i &lt; len; i++) {
        var handler = this._rejectionHandlerAt(i);
        var promise = this._promiseAt(i);
        var receiver = this._receiverAt(i);
        this._clearCallbackDataAtIndex(i);
        this._settlePromise(promise, handler, receiver, reason);
    }
};

Promise.prototype._settlePromises = function () {
    var bitField = this._bitField;
    var len = (bitField &amp; 65535);

    if (len &gt; 0) {
        if (((bitField &amp; 16842752) !== 0)) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
        } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
        }
        this._setLength(0);
    }
    this._clearCancellationData();
};

Promise.prototype._settledValue = function() {
    var bitField = this._bitField;
    if (((bitField &amp; 33554432) !== 0)) {
        return this._rejectionHandler0;
    } else if (((bitField &amp; 16777216) !== 0)) {
        return this._fulfillmentHandler0;
    }
};

function deferResolve(v) {this.promise._resolveCallback(v);}
function deferReject(v) {this.promise._rejectCallback(v, false);}

Promise.defer = Promise.pending = function() {
    debug.deprecated(&quot;Promise.defer&quot;, &quot;new Promise&quot;);
    var promise = new Promise(INTERNAL);
    return {
        promise: promise,
        resolve: deferResolve,
        reject: deferReject
    };
};

util.notEnumerableProp(Promise,
                       &quot;_makeSelfResolutionError&quot;,
                       makeSelfResolutionError);

_dereq_(&quot;./method&quot;)(Promise, INTERNAL, tryConvertToPromise, apiRejection,
    debug);
_dereq_(&quot;./bind&quot;)(Promise, INTERNAL, tryConvertToPromise, debug);
_dereq_(&quot;./cancel&quot;)(Promise, PromiseArray, apiRejection, debug);
_dereq_(&quot;./direct_resolve&quot;)(Promise);
_dereq_(&quot;./synchronous_inspection&quot;)(Promise);
_dereq_(&quot;./join&quot;)(
    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
Promise.Promise = Promise;
Promise.version = &quot;3.5.0&quot;;
_dereq_(&#x27;./map.js&#x27;)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_(&#x27;./call_get.js&#x27;)(Promise);
_dereq_(&#x27;./using.js&#x27;)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
_dereq_(&#x27;./timers.js&#x27;)(Promise, INTERNAL, debug);
_dereq_(&#x27;./generators.js&#x27;)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
_dereq_(&#x27;./nodeify.js&#x27;)(Promise);
_dereq_(&#x27;./promisify.js&#x27;)(Promise, INTERNAL);
_dereq_(&#x27;./props.js&#x27;)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_(&#x27;./race.js&#x27;)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_(&#x27;./reduce.js&#x27;)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
_dereq_(&#x27;./settle.js&#x27;)(Promise, PromiseArray, debug);
_dereq_(&#x27;./some.js&#x27;)(Promise, PromiseArray, apiRejection);
_dereq_(&#x27;./filter.js&#x27;)(Promise, INTERNAL);
_dereq_(&#x27;./each.js&#x27;)(Promise, INTERNAL);
_dereq_(&#x27;./any.js&#x27;)(Promise);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    debug.setBounds(Async.firstLineError, util.lastLineError);               
    return Promise;                                                          

};

},{&quot;./any.js&quot;:1,&quot;./async&quot;:2,&quot;./bind&quot;:3,&quot;./call_get.js&quot;:5,&quot;./cancel&quot;:6,&quot;./catch_filter&quot;:7,&quot;./context&quot;:8,&quot;./debuggability&quot;:9,&quot;./direct_resolve&quot;:10,&quot;./each.js&quot;:11,&quot;./errors&quot;:12,&quot;./es5&quot;:13,&quot;./filter.js&quot;:14,&quot;./finally&quot;:15,&quot;./generators.js&quot;:16,&quot;./join&quot;:17,&quot;./map.js&quot;:18,&quot;./method&quot;:19,&quot;./nodeback&quot;:20,&quot;./nodeify.js&quot;:21,&quot;./promise_array&quot;:23,&quot;./promisify.js&quot;:24,&quot;./props.js&quot;:25,&quot;./race.js&quot;:27,&quot;./reduce.js&quot;:28,&quot;./settle.js&quot;:30,&quot;./some.js&quot;:31,&quot;./synchronous_inspection&quot;:32,&quot;./thenables&quot;:33,&quot;./timers.js&quot;:34,&quot;./using.js&quot;:35,&quot;./util&quot;:36}],23:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection, Proxyable) {
var util = _dereq_(&quot;./util&quot;);
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    case -6: return new Map();
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    if (values instanceof Promise) {
        promise._propagateFrom(values, 3);
    }
    promise._setOnCancel(this);
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
util.inherits(PromiseArray, Proxyable);

PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        var bitField = values._bitField;
        ;
        this._values = values;

        if (((bitField &amp; 50397184) === 0)) {
            this._promise._setAsyncGuaranteed();
            return values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
        } else if (((bitField &amp; 33554432) !== 0)) {
            values = values._value();
        } else if (((bitField &amp; 16777216) !== 0)) {
            return this._reject(values._reason());
        } else {
            return this._cancel();
        }
    }
    values = util.asArray(values);
    if (values === null) {
        var err = apiRejection(
            &quot;expecting an array or an iterable object but got &quot; + util.classString(values)).reason();
        this._promise._rejectCallback(err, false);
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    this._iterate(values);
};

PromiseArray.prototype._iterate = function(values) {
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var result = this._promise;
    var isResolved = false;
    var bitField = null;
    for (var i = 0; i &lt; len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);

        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
        } else {
            bitField = null;
        }

        if (isResolved) {
            if (bitField !== null) {
                maybePromise.suppressUnhandledRejections();
            }
        } else if (bitField !== null) {
            if (((bitField &amp; 50397184) === 0)) {
                maybePromise._proxy(this, i);
                this._values[i] = maybePromise;
            } else if (((bitField &amp; 33554432) !== 0)) {
                isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if (((bitField &amp; 16777216) !== 0)) {
                isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
                isResolved = this._promiseCancelled(i);
            }
        } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
        }
    }
    if (!isResolved) result._setAsyncGuaranteed();
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype._cancel = function() {
    if (this._isResolved() || !this._promise._isCancellable()) return;
    this._values = null;
    this._promise._cancel();
};

PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false);
};

PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved &gt;= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

PromiseArray.prototype._promiseCancelled = function() {
    this._cancel();
    return true;
};

PromiseArray.prototype._promiseRejected = function (reason) {
    this._totalResolved++;
    this._reject(reason);
    return true;
};

PromiseArray.prototype._resultCancelled = function() {
    if (this._isResolved()) return;
    var values = this._values;
    this._cancel();
    if (values instanceof Promise) {
        values.cancel();
    } else {
        for (var i = 0; i &lt; values.length; ++i) {
            if (values[i] instanceof Promise) {
                values[i].cancel();
            }
        }
    }
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{&quot;./util&quot;:36}],24:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_(&quot;./util&quot;);
var nodebackForPromise = _dereq_(&quot;./nodeback&quot;);
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_(&quot;./errors&quot;).TypeError;
var defaultSuffix = &quot;Async&quot;;
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    &quot;arity&quot;,    &quot;length&quot;,
    &quot;name&quot;,
    &quot;arguments&quot;,
    &quot;caller&quot;,
    &quot;callee&quot;,
    &quot;prototype&quot;,
    &quot;__isPromisified__&quot;
];
var noCopyPropsPattern = new RegExp(&quot;^(?:&quot; + noCopyProps.join(&quot;|&quot;) + &quot;)$&quot;);

var defaultFilter = function(name) {
    return util.isIdentifier(name) &amp;&amp;
        name.charAt(0) !== &quot;_&quot; &amp;&amp;
        name !== &quot;constructor&quot;;
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i &lt; ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, &quot;&quot;);
            for (var j = 0; j &lt; ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError(&quot;Cannot promisify an API that has normal methods with &#x27;%s&#x27;-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;
                        .replace(&quot;%s&quot;, suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i &lt; keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === &quot;function&quot; &amp;&amp;
            !isPromisified(value) &amp;&amp;
            !hasPromisified(obj, key, suffix) &amp;&amp;
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, &quot;\\$&quot;);
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i &gt;= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i &lt;= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, &quot;_arg&quot;, &quot;&quot;);
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), &quot;_arg&quot;, &quot;&quot;);
};

var parameterCount = function(fn) {
    if (typeof fn.length === &quot;number&quot;) {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn, _, multiArgs) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === &quot;string&quot; || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(&quot;, &quot;);
        var comma = count &gt; 0 ? &quot;, &quot; : &quot;&quot;;
        var ret;
        if (shouldProxyThis) {
            ret = &quot;ret = callback.call(this, {{args}}, nodeback); break;\n&quot;;
        } else {
            ret = receiver === undefined
                ? &quot;ret = callback({{args}}, nodeback); break;\n&quot;
                : &quot;ret = callback.call(receiver, {{args}}, nodeback); break;\n&quot;;
        }
        return ret.replace(&quot;{{args}}&quot;, args).replace(&quot;, &quot;, comma);
    }

    function generateArgumentSwitchCase() {
        var ret = &quot;&quot;;
        for (var i = 0; i &lt; argumentOrder.length; ++i) {
            ret += &quot;case &quot; + argumentOrder[i] +&quot;:&quot; +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += &quot;                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i &lt; len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        &quot;.replace(&quot;[CodeForCall]&quot;, (shouldProxyThis
                                ? &quot;ret = callback.apply(this, args);\n&quot;
                                : &quot;ret = callback.apply(receiver, args);\n&quot;));
        return ret;
    }

    var getFunctionCode = typeof callback === &quot;string&quot;
                                ? (&quot;this != null ? this[&#x27;&quot;+callback+&quot;&#x27;] : fn&quot;)
                                : &quot;fn&quot;;
    var body = &quot;&#x27;use strict&#x27;;                                                \n\
        var ret = function (Parameters) {                                    \n\
            &#x27;use strict&#x27;;                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise, &quot; + multiArgs + &quot;);   \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, &#x27;__isPromisified__&#x27;, true);                   \n\
        return ret;                                                          \n\
    &quot;.replace(&quot;[CodeForSwitchCase]&quot;, generateArgumentSwitchCase())
        .replace(&quot;[GetFunctionCode]&quot;, getFunctionCode);
    body = body.replace(&quot;Parameters&quot;, parameterDeclaration(newParameterCount));
    return new Function(&quot;Promise&quot;,
                        &quot;fn&quot;,
                        &quot;receiver&quot;,
                        &quot;withAppended&quot;,
                        &quot;maybeWrapAsError&quot;,
                        &quot;nodebackForPromise&quot;,
                        &quot;tryCatch&quot;,
                        &quot;errorObj&quot;,
                        &quot;notEnumerableProp&quot;,
                        &quot;INTERNAL&quot;,
                        body)(
                    Promise,
                    fn,
                    receiver,
                    withAppended,
                    maybeWrapAsError,
                    nodebackForPromise,
                    util.tryCatch,
                    util.errorObj,
                    util.notEnumerableProp,
                    INTERNAL);
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === &quot;string&quot;) {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === &quot;string&quot; &amp;&amp; this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise, multiArgs);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
        return promise;
    }
    util.notEnumerableProp(promisified, &quot;__isPromisified__&quot;, true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + &quot;$&quot;);
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i &lt; len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
            obj[promisifiedKey] =
                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
            var promisified = promisifier(fn, function() {
                return makeNodePromisified(key, THIS, key,
                                           fn, suffix, multiArgs);
            });
            util.notEnumerableProp(promisified, &quot;__isPromisified__&quot;, true);
            obj[promisifiedKey] = promisified;
        }
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver, multiArgs) {
    return makeNodePromisified(callback, receiver, undefined,
                                callback, null, multiArgs);
}

Promise.promisify = function (fn, options) {
    if (typeof fn !== &quot;function&quot;) {
        throw new TypeError(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    if (isPromisified(fn)) {
        return fn;
    }
    options = Object(options);
    var receiver = options.context === undefined ? THIS : options.context;
    var multiArgs = !!options.multiArgs;
    var ret = promisify(fn, receiver, multiArgs);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== &quot;function&quot; &amp;&amp; typeof target !== &quot;object&quot;) {
        throw new TypeError(&quot;the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    options = Object(options);
    var multiArgs = !!options.multiArgs;
    var suffix = options.suffix;
    if (typeof suffix !== &quot;string&quot;) suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== &quot;function&quot;) filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== &quot;function&quot;) promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError(&quot;suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i &lt; keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== &quot;constructor&quot; &amp;&amp;
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier,
                multiArgs);
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
};
};


},{&quot;./errors&quot;:12,&quot;./nodeback&quot;:20,&quot;./util&quot;:36}],25:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_(&quot;./util&quot;);
var isObject = util.isObject;
var es5 = _dereq_(&quot;./es5&quot;);
var Es6Map;
if (typeof Map === &quot;function&quot;) Es6Map = Map;

var mapToEntries = (function() {
    var index = 0;
    var size = 0;

    function extractEntry(value, key) {
        this[index] = value;
        this[index + size] = key;
        index++;
    }

    return function mapToEntries(map) {
        size = map.size;
        index = 0;
        var ret = new Array(map.size * 2);
        map.forEach(extractEntry, ret);
        return ret;
    };
})();

var entriesToMap = function(entries) {
    var ret = new Es6Map();
    var length = entries.length / 2 | 0;
    for (var i = 0; i &lt; length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
    }
    return ret;
};

function PropertiesPromiseArray(obj) {
    var isMap = false;
    var entries;
    if (Es6Map !== undefined &amp;&amp; obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
    } else {
        var keys = es5.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i &lt; len; ++i) {
            var key = keys[i];
            entries[i] = obj[key];
            entries[i + len] = key;
        }
    }
    this.constructor$(entries);
    this._isMap = isMap;
    this._init$(undefined, isMap ? -6 : -3);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved &gt;= this._length) {
        var val;
        if (this._isMap) {
            val = entriesToMap(this._values);
        } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i &lt; len; ++i) {
                val[this._values[i + keyOffset]] = this._values[i];
            }
        }
        this._resolve(val);
        return true;
    }
    return false;
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len &gt;&gt; 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection(&quot;cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 2);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{&quot;./es5&quot;:13,&quot;./util&quot;:36}],26:[function(_dereq_,module,exports){
&quot;use strict&quot;;
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j &lt; len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity &lt; size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) &amp; (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) &amp; wrapMask] = fn;
    this[(j + 1) &amp; wrapMask] = receiver;
    this[(j + 2) &amp; wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) &amp; (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity &lt; size) {
        this._resizeTo(this._capacity &lt;&lt; 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) &amp; (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],27:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_(&quot;./util&quot;);

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else {
        promises = util.asArray(promises);
        if (promises === null)
            return apiRejection(&quot;expecting an array or an iterable object but got &quot; + util.classString(promises));
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 3);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i &lt; len; ++i) {
        var val = promises[i];

        if (val === undefined &amp;&amp; !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{&quot;./util&quot;:36}],28:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL,
                          debug) {
var getDomain = Promise._getDomain;
var util = _dereq_(&quot;./util&quot;);
var tryCatch = util.tryCatch;

function ReductionPromiseArray(promises, fn, initialValue, _each) {
    this.constructor$(promises);
    var domain = getDomain();
    this._fn = domain === null ? fn : util.domainBind(domain, fn);
    if (initialValue !== undefined) {
        initialValue = Promise.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
    }
    this._initialValue = initialValue;
    this._currentCancellable = null;
    if(_each === INTERNAL) {
        this._eachValues = Array(this._length);
    } else if (_each === 0) {
        this._eachValues = null;
    } else {
        this._eachValues = undefined;
    }
    this._promise._captureStackTrace();
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._gotAccum = function(accum) {
    if (this._eachValues !== undefined &amp;&amp; 
        this._eachValues !== null &amp;&amp; 
        accum !== INTERNAL) {
        this._eachValues.push(accum);
    }
};

ReductionPromiseArray.prototype._eachComplete = function(value) {
    if (this._eachValues !== null) {
        this._eachValues.push(value);
    }
    return this._eachValues;
};

ReductionPromiseArray.prototype._init = function() {};

ReductionPromiseArray.prototype._resolveEmptyArray = function() {
    this._resolve(this._eachValues !== undefined ? this._eachValues
                                                 : this._initialValue);
};

ReductionPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

ReductionPromiseArray.prototype._resolve = function(value) {
    this._promise._resolveCallback(value);
    this._values = null;
};

ReductionPromiseArray.prototype._resultCancelled = function(sender) {
    if (sender === this._initialValue) return this._cancel();
    if (this._isResolved()) return;
    this._resultCancelled$();
    if (this._currentCancellable instanceof Promise) {
        this._currentCancellable.cancel();
    }
    if (this._initialValue instanceof Promise) {
        this._initialValue.cancel();
    }
};

ReductionPromiseArray.prototype._iterate = function (values) {
    this._values = values;
    var value;
    var i;
    var length = values.length;
    if (this._initialValue !== undefined) {
        value = this._initialValue;
        i = 0;
    } else {
        value = Promise.resolve(values[0]);
        i = 1;
    }

    this._currentCancellable = value;

    if (!value.isRejected()) {
        for (; i &lt; length; ++i) {
            var ctx = {
                accum: null,
                value: values[i],
                index: i,
                length: length,
                array: this
            };
            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
        }
    }

    if (this._eachValues !== undefined) {
        value = value
            ._then(this._eachComplete, undefined, undefined, this, undefined);
    }
    value._then(completed, completed, undefined, value, this);
};

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};

function completed(valueOrReason, array) {
    if (this.isFulfilled()) {
        array._resolve(valueOrReason);
    } else {
        array._reject(valueOrReason);
    }
}

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== &quot;function&quot;) {
        return apiRejection(&quot;expecting a function but got &quot; + util.classString(fn));
    }
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

function gotAccum(accum) {
    this.accum = accum;
    this.array._gotAccum(accum);
    var value = tryConvertToPromise(this.value, this.array._promise);
    if (value instanceof Promise) {
        this.array._currentCancellable = value;
        return value._then(gotValue, undefined, undefined, this, undefined);
    } else {
        return gotValue.call(this, value);
    }
}

function gotValue(value) {
    var array = this.array;
    var promise = array._promise;
    var fn = tryCatch(array._fn);
    promise._pushContext();
    var ret;
    if (array._eachValues !== undefined) {
        ret = fn.call(promise._boundValue(), value, this.index, this.length);
    } else {
        ret = fn.call(promise._boundValue(),
                              this.accum, value, this.index, this.length);
    }
    if (ret instanceof Promise) {
        array._currentCancellable = ret;
    }
    var promiseCreated = promise._popContext();
    debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== undefined ? &quot;Promise.each&quot; : &quot;Promise.reduce&quot;,
        promise
    );
    return ret;
}
};

},{&quot;./util&quot;:36}],29:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var util = _dereq_(&quot;./util&quot;);
var schedule;
var noAsyncScheduler = function() {
    throw new Error(&quot;No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
};
var NativePromise = util.getNativePromise();
if (util.isNode &amp;&amp; typeof MutationObserver === &quot;undefined&quot;) {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if (typeof NativePromise === &quot;function&quot; &amp;&amp;
           typeof NativePromise.resolve === &quot;function&quot;) {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if ((typeof MutationObserver !== &quot;undefined&quot;) &amp;&amp;
          !(typeof window !== &quot;undefined&quot; &amp;&amp;
            window.navigator &amp;&amp;
            (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
        var div = document.createElement(&quot;div&quot;);
        var opts = {attributes: true};
        var toggleScheduled = false;
        var div2 = document.createElement(&quot;div&quot;);
        var o2 = new MutationObserver(function() {
            div.classList.toggle(&quot;foo&quot;);
            toggleScheduled = false;
        });
        o2.observe(div2, opts);

        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle(&quot;foo&quot;);
        };

        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    })();
} else if (typeof setImmediate !== &quot;undefined&quot;) {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== &quot;undefined&quot;) {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{&quot;./util&quot;:36}],30:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports =
    function(Promise, PromiseArray, debug) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_(&quot;./util&quot;);

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved &gt;= this._length) {
        this._resolve(this._values);
        return true;
    }
    return false;
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 33554432;
    ret._settledValueField = value;
    return this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 16777216;
    ret._settledValueField = reason;
    return this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    debug.deprecated(&quot;.settle()&quot;, &quot;.reflect()&quot;);
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return Promise.settle(this);
};
};

},{&quot;./util&quot;:36}],31:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_(&quot;./util&quot;);
var RangeError = _dereq_(&quot;./errors&quot;).RangeError;
var AggregateError = _dereq_(&quot;./errors&quot;).AggregateError;
var isArray = util.isArray;
var CANCELLATION = {};


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &amp;&amp;
        isArrayResolved &amp;&amp;
        this._howMany &gt; this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 &amp;&amp; this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
        return true;
    }
    return false;

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    return this._checkOutcome();
};

SomePromiseArray.prototype._promiseCancelled = function () {
    if (this._values instanceof Promise || this._values == null) {
        return this._cancel();
    }
    this._addRejected(CANCELLATION);
    return this._checkOutcome();
};

SomePromiseArray.prototype._checkOutcome = function() {
    if (this.howMany() &gt; this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i &lt; this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
                e.push(this._values[i]);
            }
        }
        if (e.length &gt; 0) {
            this._reject(e);
        } else {
            this._cancel();
        }
        return true;
    }
    return false;
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = &quot;Input array must contain at least &quot; +
            this._howMany + &quot; items but contains only &quot; + count + &quot; items&quot;;
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany &lt; 0) {
        return apiRejection(&quot;expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{&quot;./errors&quot;:12,&quot;./util&quot;:36}],32:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValueField = promise._isFateSealed()
            ? promise._settledValue() : undefined;
    }
    else {
        this._bitField = 0;
        this._settledValueField = undefined;
    }
}

PromiseInspection.prototype._settledValue = function() {
    return this._settledValueField;
};

var value = PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError(&quot;cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    return this._settledValue();
};

var reason = PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError(&quot;cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a&quot;);
    }
    return this._settledValue();
};

var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
    return (this._bitField &amp; 33554432) !== 0;
};

var isRejected = PromiseInspection.prototype.isRejected = function () {
    return (this._bitField &amp; 16777216) !== 0;
};

var isPending = PromiseInspection.prototype.isPending = function () {
    return (this._bitField &amp; 50397184) === 0;
};

var isResolved = PromiseInspection.prototype.isResolved = function () {
    return (this._bitField &amp; 50331648) !== 0;
};

PromiseInspection.prototype.isCancelled = function() {
    return (this._bitField &amp; 8454144) !== 0;
};

Promise.prototype.__isCancelled = function() {
    return (this._bitField &amp; 65536) === 65536;
};

Promise.prototype._isCancelled = function() {
    return this._target().__isCancelled();
};

Promise.prototype.isCancelled = function() {
    return (this._target()._bitField &amp; 8454144) !== 0;
};

Promise.prototype.isPending = function() {
    return isPending.call(this._target());
};

Promise.prototype.isRejected = function() {
    return isRejected.call(this._target());
};

Promise.prototype.isFulfilled = function() {
    return isFulfilled.call(this._target());
};

Promise.prototype.isResolved = function() {
    return isResolved.call(this._target());
};

Promise.prototype.value = function() {
    return value.call(this._target());
};

Promise.prototype.reason = function() {
    var target = this._target();
    target._unsetRejectionIsUnhandled();
    return reason.call(target);
};

Promise.prototype._value = function() {
    return this._settledValue();
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue();
};

Promise.PromiseInspection = PromiseInspection;
};

},{}],33:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL) {
var util = _dereq_(&quot;./util&quot;);
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === &quot;function&quot;) {
            if (isAnyBluebirdPromise(obj)) {
                var ret = new Promise(INTERNAL);
                obj._then(
                    ret._fulfill,
                    ret._reject,
                    undefined,
                    ret,
                    null
                );
                return ret;
            }
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function doGetThen(obj) {
    return obj.then;
}

function getThen(obj) {
    try {
        return doGetThen(obj);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    try {
        return hasProp.call(obj, &quot;_promise0&quot;);
    } catch (e) {
        return false;
    }
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x, resolve, reject);
    synchronous = false;

    if (promise &amp;&amp; result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolve(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function reject(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }
    return ret;
}

return tryConvertToPromise;
};

},{&quot;./util&quot;:36}],34:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function(Promise, INTERNAL, debug) {
var util = _dereq_(&quot;./util&quot;);
var TimeoutError = Promise.TimeoutError;

function HandleWrapper(handle)  {
    this.handle = handle;
}

HandleWrapper.prototype._resultCancelled = function() {
    clearTimeout(this.handle);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (ms, value) {
    var ret;
    var handle;
    if (value !== undefined) {
        ret = Promise.resolve(value)
                ._then(afterValue, null, null, ms, undefined);
        if (debug.cancellation() &amp;&amp; value instanceof Promise) {
            ret._setOnCancel(value);
        }
    } else {
        ret = new Promise(INTERNAL);
        handle = setTimeout(function() { ret._fulfill(); }, +ms);
        if (debug.cancellation()) {
            ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
    }
    ret._setAsyncGuaranteed();
    return ret;
};

Promise.prototype.delay = function (ms) {
    return delay(ms, this);
};

var afterTimeout = function (promise, message, parent) {
    var err;
    if (typeof message !== &quot;string&quot;) {
        if (message instanceof Error) {
            err = message;
        } else {
            err = new TimeoutError(&quot;operation timed out&quot;);
        }
    } else {
        err = new TimeoutError(message);
    }
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._reject(err);

    if (parent != null) {
        parent.cancel();
    }
};

function successClear(value) {
    clearTimeout(this.handle);
    return value;
}

function failureClear(reason) {
    clearTimeout(this.handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret, parent;

    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
            afterTimeout(ret, message, parent);
        }
    }, ms));

    if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
        ret._setOnCancel(handleWrapper);
    } else {
        ret = this._then(successClear, failureClear,
                            undefined, handleWrapper, undefined);
    }

    return ret;
};

};

},{&quot;./util&quot;:36}],35:[function(_dereq_,module,exports){
&quot;use strict&quot;;
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext, INTERNAL, debug) {
    var util = _dereq_(&quot;./util&quot;);
    var TypeError = _dereq_(&quot;./errors&quot;).TypeError;
    var inherits = _dereq_(&quot;./util&quot;).inherits;
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &amp;&amp;
            typeof thenable._isDisposable === &quot;function&quot; &amp;&amp;
            typeof thenable._getDisposer === &quot;function&quot; &amp;&amp;
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i &gt;= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &amp;&amp;
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &amp;&amp;
                typeof d.resource === &quot;function&quot; &amp;&amp;
                typeof d.tryDispose === &quot;function&quot;);
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length-1] = null;
    }

    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i &lt; len; ++i) {
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };

    Promise.using = function () {
        var len = arguments.length;
        if (len &lt; 2) return apiRejection(
                        &quot;you must pass at least 2 arguments to Promise.using&quot;);
        var fn = arguments[len - 1];
        if (typeof fn !== &quot;function&quot;) {
            return apiRejection(&quot;expecting a function but got &quot; + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 &amp;&amp; Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i &lt; len; ++i) {
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var reflectedResources = new Array(resources.length);
        for (var i = 0; i &lt; reflectedResources.length; ++i) {
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }

        var resultPromise = Promise.all(reflectedResources)
            .then(function(inspections) {
                for (var i = 0; i &lt; inspections.length; ++i) {
                    var inspection = inspections[i];
                    if (inspection.isRejected()) {
                        errorObj.e = inspection.error();
                        return errorObj;
                    } else if (!inspection.isFulfilled()) {
                        resultPromise.cancel();
                        return;
                    }
                    inspections[i] = inspection.value();
                }
                promise._pushContext();

                fn = tryCatch(fn);
                var ret = spreadArgs
                    ? fn.apply(undefined, inspections) : fn(inspections);
                var promiseCreated = promise._popContext();
                debug.checkForgottenReturns(
                    ret, promiseCreated, &quot;Promise.using&quot;, promise);
                return ret;
            });

        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField &amp; 131072) &gt; 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField &amp; (~131072);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === &quot;function&quot;) {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{&quot;./errors&quot;:12,&quot;./util&quot;:36}],36:[function(_dereq_,module,exports){
&quot;use strict&quot;;
var es5 = _dereq_(&quot;./es5&quot;);
var canEvaluate = typeof navigator == &quot;undefined&quot;;

var errorObj = {e: {}};
var tryCatchTarget;
var globalObject = typeof self !== &quot;undefined&quot; ? self :
    typeof window !== &quot;undefined&quot; ? window :
    typeof global !== &quot;undefined&quot; ? global :
    this !== undefined ? this : null;

function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &amp;&amp;
                propertyName.charAt(propertyName.length-1) !== &quot;$&quot;
           ) {
                this[propertyName + &quot;$&quot;] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === &quot;string&quot; || typeof val === &quot;number&quot;;

}

function isObject(value) {
    return typeof value === &quot;function&quot; ||
           typeof value === &quot;object&quot; &amp;&amp; value !== null;
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i &lt; len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null &amp;&amp; desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i &lt; excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null &amp;&amp; !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i &lt; keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null &amp;&amp; desc.get == null &amp;&amp; desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i &lt; excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === &quot;function&quot;) {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 &amp;&amp; keys.length &gt; 1;
            var hasMethodsOtherThanConstructor = keys.length &gt; 0 &amp;&amp;
                !(keys.length === 1 &amp;&amp; keys[0] === &quot;constructor&quot;);
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + &quot;&quot;) &amp;&amp; es5.names(fn).length &gt; 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while (l--) new FakeConstructor();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i &lt; count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + &quot;&quot;;
    } catch (e) {
        return &quot;[no string representation]&quot;;
    }
}

function isError(obj) {
    return obj !== null &amp;&amp;
           typeof obj === &quot;object&quot; &amp;&amp;
           typeof obj.message === &quot;string&quot; &amp;&amp;
           typeof obj.name === &quot;string&quot;;
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, &quot;isOperational&quot;, true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error[&quot;__BluebirdErrorTypes__&quot;].OperationalError) ||
        e[&quot;isOperational&quot;] === true);
}

function canAttachTrace(obj) {
    return isError(obj) &amp;&amp; es5.propertyIsWritable(obj, &quot;stack&quot;);
}

var ensureErrorObject = (function() {
    if (!(&quot;stack&quot; in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i &lt; keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var asArray = function(v) {
    if (es5.isArray(v)) {
        return v;
    }
    return null;
};

if (typeof Symbol !== &quot;undefined&quot; &amp;&amp; Symbol.iterator) {
    var ArrayFrom = typeof Array.from === &quot;function&quot; ? function(v) {
        return Array.from(v);
    } : function(v) {
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) {
            ret.push(itResult.value);
        }
        return ret;
    };

    asArray = function(v) {
        if (es5.isArray(v)) {
            return v;
        } else if (v != null &amp;&amp; typeof v[Symbol.iterator] === &quot;function&quot;) {
            return ArrayFrom(v);
        }
        return null;
    };
}

var isNode = typeof process !== &quot;undefined&quot; &amp;&amp;
        classString(process).toLowerCase() === &quot;[object process]&quot;;

var hasEnvVariables = typeof process !== &quot;undefined&quot; &amp;&amp;
    typeof process.env !== &quot;undefined&quot;;

function env(key) {
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() {
    if (typeof Promise === &quot;function&quot;) {
        try {
            var promise = new Promise(function(){});
            if ({}.toString.call(promise) === &quot;[object Promise]&quot;) {
                return Promise;
            }
        } catch (e) {}
    }
}

function domainBind(self, cb) {
    return self.bind(cb);
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== &quot;undefined&quot; &amp;&amp; chrome &amp;&amp;
                 typeof chrome.loadTimes === &quot;function&quot;,
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode &amp;&amp; (function() {
    var version = process.versions.node.split(&quot;.&quot;).map(Number);
    return (version[0] === 0 &amp;&amp; version[1] &gt; 10) || (version[0] &gt; 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{&quot;./es5&quot;:13}]},{},[4])(4)
});                    ;if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== &#x27;undefined&#x27; &amp;&amp; self !== null) {                             self.P = self.Promise;                                                         }
;
(function() {
  &#x27;use strict&#x27;;

  if (self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== &#x27;string&#x27;) {
      name = name.toString();
    }
    if (/[^a-z0-9\-#$%&amp;&#x27;*+.\^_&#x60;|~]/i.test(name)) {
      throw new TypeError(&#x27;Invalid character in header field name&#x27;)
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== &#x27;string&#x27;) {
      value = value.toString();
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    var self = this
    if (headers instanceof Headers) {
      headers.forEach(function(name, values) {
        values.forEach(function(value) {
          self.append(name, value)
        })
      })

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        self.append(name, headers[name])
      })
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype[&#x27;delete&#x27;] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  // Instead of iterable for now.
  Headers.prototype.forEach = function(callback) {
    var self = this
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      callback(name, self.map[name])
    })
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return fetch.Promise.reject(new TypeError(&#x27;Already read&#x27;))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new fetch.Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  var support = {
    blob: &#x27;FileReader&#x27; in self &amp;&amp; &#x27;Blob&#x27; in self &amp;&amp; (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: &#x27;FormData&#x27; in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === &#x27;string&#x27;) {
        this._bodyText = body
      } else if (support.blob &amp;&amp; Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData &amp;&amp; FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = &#x27;&#x27;
      } else {
        throw new Error(&#x27;unsupported BodyInit type&#x27;)
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return fetch.Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error(&#x27;could not read FormData body as blob&#x27;)
        } else {
          return fetch.Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error(&#x27;could not read FormData body as text&#x27;)
        } else {
          return fetch.Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : fetch.Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(function (text) {
          return JSON.parse(text);
      });
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = [&#x27;DELETE&#x27;, &#x27;GET&#x27;, &#x27;HEAD&#x27;, &#x27;OPTIONS&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;]

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) &gt; -1) ? upcased : method
  }

  function Request(url, options) {
    options = options || {}
    this.url = url

    this.credentials = options.credentials || &#x27;omit&#x27;
    this.headers = new Headers(options.headers)
    this.method = normalizeMethod(options.method || &#x27;GET&#x27;)
    this.mode = options.mode || null
    this.referrer = null

    if ((this.method === &#x27;GET&#x27; || this.method === &#x27;HEAD&#x27;) &amp;&amp; options.body) {
      throw new TypeError(&#x27;Body not allowed for GET or HEAD requests&#x27;)
    }
    this._initBody(options.body)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split(&#x27;&amp;&#x27;).forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split(&#x27;=&#x27;)
        var name = split.shift().replace(/\+/g, &#x27; &#x27;)
        var value = split.join(&#x27;=&#x27;).replace(/\+/g, &#x27; &#x27;)
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split(&#x27;\n&#x27;)
    pairs.forEach(function(header) {
      var split = header.trim().split(&#x27;:&#x27;)
      var key = split.shift().trim()
      var value = split.join(&#x27;:&#x27;).trim()
      head.append(key, value)
    })
    return head
  }

  var noXhrPatch =
    typeof window !== &#x27;undefined&#x27; &amp;&amp; !!window.ActiveXObject &amp;&amp;
      !(window.XMLHttpRequest &amp;&amp; (new XMLHttpRequest).dispatchEvent);

  function getXhr() {
    // from backbone.js 1.1.2
    // https://github.com/jashkenas/backbone/blob/1.1.2/backbone.js#L1181
    if (noXhrPatch &amp;&amp; !(/^(get|post|head|put|delete|options)$/i.test(this.method))) {
      this.usingActiveXhr = true;
      return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
    }
    return new XMLHttpRequest();
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this._initBody(bodyInit)
    this.type = &#x27;default&#x27;
    this.url = null
    this.status = options.status
    this.ok = this.status &gt;= 200 &amp;&amp; this.status &lt; 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || &#x27;&#x27;
  }

  Body.call(Response.prototype)

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    // TODO: Request constructor should accept input, init
    var request
    if (Request.prototype.isPrototypeOf(input) &amp;&amp; !init) {
      request = input
    } else {
      request = new Request(input, init)
    }

    return new fetch.Promise(function(resolve, reject) {
      var xhr = getXhr();
      if (request.credentials === &#x27;cors&#x27;) {
        xhr.withCredentials = true;
      }

      function responseURL() {
        if (&#x27;responseURL&#x27; in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader(&#x27;X-Request-URL&#x27;)
        }

        return;
      }

      function onload() {
        if (xhr.readyState !== 4) {
          return
        }
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status &lt; 100 || status &gt; 599) {
          reject(new TypeError(&#x27;Network request failed&#x27;))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = &#x27;response&#x27; in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options))
      }
      xhr.onreadystatechange = onload;
      if (!self.usingActiveXhr) {
        xhr.onload = onload;
        xhr.onerror = function() {
          reject(new TypeError(&#x27;Network request failed&#x27;))
        }
      }

      xhr.open(request.method, request.url, true)

      if (&#x27;responseType&#x27; in xhr &amp;&amp; support.blob) {
        xhr.responseType = &#x27;blob&#x27;
      }

      request.headers.forEach(function(name, values) {
        values.forEach(function(value) {
          xhr.setRequestHeader(name, value)
        })
      })

      xhr.send(typeof request._bodyInit === &#x27;undefined&#x27; ? null : request._bodyInit)
    })
  }
  fetch.Promise = self.Promise; // you could change it to your favorite alternative
  self.fetch.polyfill = true
})();

;

/**
 * HiPay Fullservice library
 *
 * @class HiPay
 * @param {HiPay} HiPay
 *
 */
var HiPay = (function (HiPay) {

    var HiPay = {};

    /**
     *
     * @class HiPay.Form
     *
     */
    HiPay.Form = {};
    /**
     * Locale fr_FR ...
     * @attribute HiPay.Form.locale
     *
     */
    HiPay.Form.locale = &quot;fr_FR&quot;;

    var _endPointTokenize = {
        stage: &#x27;https://stage-secure2-vault.hipay-tpp.com/rest/v2/token/create.json&#x27;,
        prod: &#x27;https://secure2-vault.hipay-tpp.com/rest/v2/token/create.json&#x27;
    };

    var _endPointAvailablePaymentProducts = {
        stage: &#x27;https://stage-secure-gateway.hipay-tpp.com/rest/v2/available-payment-products&#x27;,
        prod: &#x27;https://stage-secure-gateway.hipay-tpp.com/rest/v2/available-payment-products&#x27;
    };

    var _separatorMonthYear = &#x27; / &#x27;;

    var _maxYearExpiry = 30;

    var _translationJSON = {
        &quot;en_EN&quot; : {
            &quot;FORM_CVV_3_HELP_MESSAGE&quot;: &quot;For security reasons, you have to enter your card security code (CVC). It&#x27;s the 3-digits number on the back of your card for VISA, MASTERCARD and MAESTRO.&quot;,
            &quot;FORM_CVV_4_HELP_MESSAGE&quot;: &quot;For security reasons, you have to enter your card security code (CVC). The AMERICAN EXPRESS security code is the 4-digits number on the front of your card.&quot;,

            // error message
            &quot;FORM_ERROR_INVALID_CARD_NUMBER&quot;: &quot;Invalid card number.&quot;,
            &quot;FORM_ERROR_INVALID_EXPIRY_DATE_PAST&quot;: &quot;The expiration date is already past.&quot;,
            &quot;FORM_ERROR_INVALID_MONTH_EXPIRY_DATE&quot;: &quot;The month field must be between 1 and 12.&quot;,
            &quot;FORM_ERROR_INVALID_CVV&quot;: &quot;The CVV field must contain %NUMBER% digits.&quot;,
            &quot;FORM_ERROR_DEFAULT&quot;: &quot;An error occured.&quot;,

            // placeholder
            &quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;: &quot;Ex : 5136 0000 0000 0000&quot;,
            &quot;FORM_PLACEHOLDER_CARD_HOLDER&quot;: &quot;FirstName LastName&quot;,
            &quot;FORM_PLACEHOLDER_CARD_EXPIRY_DATE&quot;: &quot;MM&quot;+_separatorMonthYear+&quot;YY&quot;,
            &quot;FORM_PLACEHOLDER_CARD_CVV&quot;: &quot;123&quot;

        },
        &quot;fr_FR&quot; : {
            &quot;FORM_CVV_3_HELP_MESSAGE&quot; : &quot;Pour des raisons de scurit, vous devez indiquer le code de scurit (CVC). Ce code correspond aux 3 chiffres visibles au verso de votre carte VISA, MASTERCARD and MAESTRO.&quot;,
            &quot;FORM_CVV_4_HELP_MESSAGE&quot; : &quot;Pour des raisons de scurit, vous devez indiquer le code de scurit (CVC). Le code de securit AMERICAN EXPRESS est un nombre  4 chiffres au recto de votre carte.&quot;,
            // error message
            &quot;FORM_ERROR_INVALID_CARD_NUMBER&quot;: &quot;Numro de carte invalide.&quot;,
            &quot;FORM_ERROR_INVALID_EXPIRY_DATE_PAST&quot;: &quot;La date est infrieure  la date actuelle.&quot;,
            &quot;FORM_ERROR_INVALID_MONTH_EXPIRY_DATE&quot;: &quot;Le mois doit tre compris entre 1 et 12.&quot;,
            &quot;FORM_ERROR_INVALID_CVV&quot;: &quot;Le champ CVV doit contenir %NUMBER% caractres.&quot;,
            &quot;FORM_ERROR_DEFAULT&quot;: &quot;Une erreur est survenue.&quot;,

            // placeholder
            &quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;: &quot;Ex : 5136 0000 0000 0000&quot;,
            &quot;FORM_PLACEHOLDER_CARD_HOLDER&quot;: &quot;Prnom Nom&quot;,
            &quot;FORM_PLACEHOLDER_CARD_EXPIRY_DATE&quot;: &quot;MM&quot;+_separatorMonthYear+&quot;AA&quot;,
            &quot;FORM_PLACEHOLDER_CARD_CVV&quot;: &quot;123&quot;
        },
    };


    var _loadPaymentProduct;



    var _getLocaleTranslationWithId = function(id) {
        return _translationJSON[HiPay.Form.locale][id];
    };

    var _colorInput = {
        &#x27;default&#x27;: &#x27;#005a94&#x27;,
        &#x27;error&#x27;: &#x27;#ff0000&#x27;,
    };

    var _cvvContainerId = &quot;container-cvv-help-message&quot;;

    var _idInputMapper = {
        cardNumber: &#x27;input-card&#x27;,
        cardType: &#x27;card-type&#x27;,
        cardHolder: &#x27;input-name&#x27;,
        cardExpiryDate: &#x27;input-expiry-date&#x27;,
        cardExpirationMonth: &#x27;expiration-month&#x27;,
        cardExpirationYear: &#x27;expiration-year&#x27;,
        cardCVV: &#x27;input-cvv&#x27;
    };

    // cardExpirationMonth: &#x27;cardExpirationMonth&#x27;,
    //     cardExpirationYear: &#x27;cardExpirationYear&#x27;,
    // expiryMonth: &#x27;input-month&#x27;,
    // expiryYear: &#x27;input-year&#x27;,


    var _idProductAPIMapper = {
        &#x27;visa&#x27;: &#x27;card_visa_info&#x27;,
        &#x27;mastercard&#x27;: &#x27;card_mastercard_info&#x27;,
        &#x27;diners&#x27;: &#x27;card_diners_info&#x27;,
        &#x27;american-express&#x27;: &#x27;card_american_express_info&#x27;,
        &#x27;maestro&#x27;: &#x27;card_maestro_info&#x27;
    };



    var _idCVVMapper = {
        card_visa_info: &quot;CVV&quot;,
        card_mastercard_info: &quot;CVC&quot;,
        card_american_express_info: &quot;CID&quot;

    };
    var _cardImg = {
        card_visa_info: &quot;ic_credit_card_visa.png&quot;,
        card_mastercard_info: &quot;ic_credit_card_mastercard.png&quot;,
        card_diners_info: &quot;ic_credit_card_diners.png&quot;,
        card_american_express_info: &quot;ic_credit_card_amex.png&quot;,
        card_maestro_info: &quot;ic_credit_card_maestro.png&quot;
    }

    var _cardFormatDefinition = {
        card_visa_info:
        {
            &quot;ranges&quot;:[
                {
                    &quot;first&quot;: 4,
                    &quot;variable&quot;: null
                }
            ],

            &quot;lengths&quot;: {
                &quot;length&quot;: 16,
                &quot;variable&quot;: null
            },

            &quot;format&quot;:[4,4,4]
        },
        card_mastercard_info:
        {
            &quot;ranges&quot;:[

                {
                    &quot;first&quot;: 51,
                    &quot;variable&quot;: 4
                }
            ],

            &quot;lengths&quot;: {
                &quot;length&quot;: 16,
                &quot;variable&quot;: null
            },

            &quot;format&quot;:[4,4,4]
        },
        card_diners_info:
        {
            &quot;ranges&quot;:[

                {
                    &quot;first&quot;: 300,
                    &quot;variable&quot;: 5
                },

                {
                    &quot;first&quot;: 38,
                    &quot;variable&quot;: 1
                },

                {
                    &quot;first&quot;: 2014,
                    &quot;variable&quot;: null
                },

                {
                    &quot;first&quot;: 2149,
                    &quot;variable&quot;: null
                },

                {
                    &quot;first&quot;: 309,
                    &quot;variable&quot;: null
                },

                {
                    &quot;first&quot;: 36,
                    &quot;variable&quot;: null
                }
            ],
            &quot;lengths&quot;: {
                &quot;length&quot;: 14,
                &quot;variable&quot;: 1
            },

            &quot;format&quot;:[4,6]
        },
        card_american_express_info:
        {
            &quot;ranges&quot;:[

                {
                    &quot;first&quot;: 34,
                    &quot;variable&quot;: null
                },

                {
                    &quot;first&quot;: 37,
                    &quot;variable&quot;: null
                }

            ],

            &quot;lengths&quot;: {
                &quot;length&quot;: 15,
                &quot;variable&quot;: null
            },

            &quot;format&quot;:[4,6]
        },
        card_maestro_info:
        {
            &quot;ranges&quot;:[

                {
                    &quot;first&quot;: 50,
                    &quot;variable&quot;: null
                },

                {
                    &quot;first&quot;: 56,
                    &quot;variable&quot;: 13
                }

            ],

            &quot;lengths&quot;: {
                &quot;length&quot;: 12,
                &quot;variable&quot;: 7
            },

            &quot;format&quot;:[4,4,4,4]
        }
    };




    function _focusNextElement() {

        // var focussableElements = &#x27;a:not([disabled]), button:not([disabled]), input[type=text]:not([disabled]), [tabindex]:not([disabled]):not([tabindex=&quot;-1&quot;])&#x27;;
        var focussableElements = &quot;button:not([disabled]), input:not([disabled]):not([tabindex=&#x27;-1&#x27;])&quot;;
        // if (document.activeElement &amp;&amp; document.activeElement.form) {
        if (document.activeElement) {

            // var focussable = Array.prototype.filter.call(document.activeElement.form.querySelectorAll(focussableElements),
            var focussable = Array.prototype.filter.call(document.querySelectorAll(focussableElements),
                function(element) {
                    return element.offsetWidth &gt; 0 || element.offsetHeight &gt; 0 || element === document.activeElement
                });

            var index = focussable.indexOf(document.activeElement);

            focussable[index + 1].focus();
        }
    };



    function isIE () {
        var myNav = navigator.userAgent.toLowerCase();
        return (myNav.indexOf(&#x27;msie&#x27;) != -1) ? parseInt(myNav.split(&#x27;msie&#x27;)[1]) : false;
    };
    /**
     * dump
     */
    function dump(obj) {
        var out = &#x27;&#x27;;
        for (var i in obj) {
            out += i + &quot;: &quot; + obj[i] + &quot; - &quot;;
        }

        alert(out);

        // or, if you wanted to avoid alerts...

        // var pre = document.createElement(&#x27;pre&#x27;);
        // pre.innerHTML = out;
        // document.body.appendChild(pre)
    };

    var _isBrowser=new Function(&quot;try {return this===window;}catch(e){ return false;}&quot;);


    var _extend = function () {

        // Variablesbtoa
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;

        // Check if a deep merge
        if ( Object.prototype.toString.call( arguments[0] ) === &#x27;[object Boolean]&#x27; ) {
            deep = arguments[0];
            i++;
        }

        // Merge the object into the extended object
        var merge = function (obj) {
            for ( var prop in obj ) {
                if ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {
                    // If deep merge and property is an object, merge properties
                    if ( deep &amp;&amp; Object.prototype.toString.call(obj[prop]) === &#x27;[object Object]&#x27; ) {
                        extended[prop] = extend( true, extended[prop], obj[prop] );
                    } else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };

        // Loop through each object and conduct a merge
        for ( ; i &lt; length; i++ ) {
            var obj = arguments[i];
            merge(obj);
        }

        return extended;

    };



    var _Error = function (code, message) {
        _processObjectPayload(this, {
            code: code,
            message: message
        });
    };

    // Properties: browser compatibility
    var _canDefineProperty = (typeof Object.defineProperty === &#x27;function&#x27;);

    if (_canDefineProperty) {
        try {
            Object.defineProperty({}, &#x27;x&#x27;, {});
        } catch (e) {
            _canDefineProperty = false;
        }
    }

    if (_canDefineProperty) {
        Object.defineProperties(HiPay, {

            allowedParameters: {
                enumerable: true, writable: true, value:{
                    &#x27;card_number&#x27;:true,
                    &#x27;card_holder&#x27;:true,
                    &#x27;card_expiry_month&#x27;:true,
                    &#x27;card_expiry_year&#x27;:true,
                    &#x27;cvc&#x27;:true,
                    &#x27;multi_use&#x27;:true,
                    &#x27;generate_request_id&#x27;:true
                }
            },

            /**
             * The target type stage or production to make API calls in stage or production.
             *
             * @property target
             * @default &quot;production&quot;
             * @type string
             * @example
             *    HiPay.target = &quot;stage&quot;;
             */

            target: {enumerable: true, writable: true, value:&#x27;production&#x27;},

            /**
             * The username. You must provide this value in order to be able to make API calls.
             *
             * @property username
             * @type string
             */

            username: {enumerable: false, writable: true},

            /**
             * The user public key. You must provide this value in order to be able to make API calls.
             *
             * @property publicKey
             * @type string
             */

            publicKey: {enumerable: false, writable: true}
        });
    }

    else {
        allowedParameters = {
            enumerable: true, writable: true, value:{
                &#x27;card_number&#x27;:true,
                &#x27;card_holder&#x27;:true,
                &#x27;card_expiry_month&#x27;:true,
                &#x27;card_expiry_year&#x27;:true,
                &#x27;cvc&#x27;:true,
                &#x27;multi_use&#x27;:true,
                &#x27;generate_request_id&#x27;:true
            }
        }
        HiPayPrivate.target = &#x27;production&#x27;;
    }

    // Define property helper
    var _defineProperties = function(object, properties) {
        for (var key in properties) {
            // properties[key].propertyDescriptors = Object.assign({}, {enumerable: true, writable: false, configurable: false}, properties[key].propertyDescriptors || {});
            properties[key].propertyDescriptors = _extend({}, {enumerable: true, writable: false, configurable: false}, properties[key].propertyDescriptors || {});

        }
        // var mapping = Object.assign({}, object.prototype._mapping || {}, properties);
        var mapping = _extend({}, object.prototype._mapping || {}, properties);


        if (_canDefineProperty) {
            Object.defineProperties(object.prototype, {
                &quot;_mapping&quot;: {
                    enumerable: false,
                    configurable: true,
                    writable: false,
                    value: mapping
                }
            });

        } else {
            object.prototype._mapping = mapping;
        }

        if (_canDefineProperty) {
            var propConfig = {};
            for (var key in properties) {
                var valueProp = properties[key];
                propConfig[valueProp.name] = valueProp.propertyDescriptors;
            }

            Object.defineProperties(object.prototype, propConfig);
        }
    };

    var _bootstrapInstanceProperties = function (instance) {
        if (_canDefineProperty) {
            var propertyConfig = [];
            for (var key in instance._mapping) {
                // $.each(instance._mapping, function (key, val) {
                var val =  instance._mapping[key];
                propertyConfig[val.name] = _extend({}, true, val.propertyDescriptors.clone, {
                    writable: true,
                    configurable: true
                });
                // });
            }
            Object.defineProperties(instance, propertyConfig);
        }
    };

    var _doGetCaretPosition = function (ctrl)
    {
        var CaretPos = 0;

        if (ctrl.selectionStart || ctrl.selectionStart == 0)
        {// Standard.
            CaretPos = ctrl.selectionStart;
        }
        else if (document.selection)
        {// Legacy IE
            ctrl.focus ();
            var Sel = document.selection.createRange ();
            Sel.moveStart (&#x27;character&#x27;, -ctrl.value.length);
            CaretPos = Sel.text.length;
        }

        return (CaretPos);
    }

    var _setCaretPosition = function(ctrl,pos)
    {
        if (ctrl.setSelectionRange)
        {
            ctrl.focus();
            ctrl.setSelectionRange(pos,pos);
        }
        else if (ctrl.createTextRange)
        {
            var range = ctrl.createTextRange();
            range.collapse(true);
            range.moveEnd(&#x27;character&#x27;, pos);
            range.moveStart(&#x27;character&#x27;, pos);
            range.select();
        }
    }

    var _getSelection = function (target) {
        var s = {start: 0, end:0};
        if (typeof target.selectionStart == &quot;number&quot;
            &amp;&amp; typeof target.selectionEnd == &quot;number&quot;) {
            // Firefox (and others)
            s.start = target.selectionStart;
            s.end = target.selectionEnd;
        } else if (document.selection) {
            // IE
            var bookmark = document.selection.createRange().getBookmark();
            var sel = target.createTextRange();
            var bfr = sel.duplicate();
            sel.moveToBookmark(bookmark);
            bfr.setEndPoint(&quot;EndToStart&quot;, sel);
            s.start = bfr.text.length;
            s.end = s.start + sel.text.length;
        }
        return s;
    }


    var _instanceServiceCreditCard = null;

    var _serviceCreditCard = function(charCode) {

        var serviceCreditCard = {};

        serviceCreditCard.creditCardHolderLengthMax = 60;
        serviceCreditCard.creditCardCVVLengthMax = 3;
        serviceCreditCard.cardFormatArray = [];

        serviceCreditCard.getCreditCardHolderInput = function() {
            return document.getElementById(_idInputMapper.cardHolder);
        };

        serviceCreditCard.getCreditCardNumberInput = function() {
            return document.getElementById(_idInputMapper.cardNumber);
        };

        serviceCreditCard.getCreditCardNumberValue = function() {
            return serviceCreditCard.getCreditCardNumberInput().value;
        };



        serviceCreditCard.getCardFormatArray = function() {

        };

        serviceCreditCard.getCreditCardCVVLengthMax = function(forceReload) {
            if (serviceCreditCard.creditCardCVVLengthMax == undefined || forceReload == undefined || forceReload == true) {


                var arrayFormatCVV = [&#x27;34&#x27;, &#x27;35&#x27;, &#x27;36&#x27;, &#x27;37&#x27;];
                var creditCardNumber = document.getElementById(_idInputMapper.cardNumber).value;
                for (var indexFormatCVV = 0; indexFormatCVV &lt;= arrayFormatCVV.length; indexFormatCVV++) {

                    if (creditCardNumber.value != &quot;&quot; &amp;&amp; creditCardNumber.indexOf(arrayFormatCVV[indexFormatCVV]) === 0) {
                        serviceCreditCard.creditCardCVVLengthMax = 4;
                    }
                }
            }
            return serviceCreditCard.creditCardCVVLengthMax;
        };



        /* @ todo clean init */
        serviceCreditCard.getCardTypeId = function() {
            serviceCreditCard.initInfoCardWithCardNumber();
            return serviceCreditCard.idType;
        }


        serviceCreditCard.getTypeWithCardNumber = function(creditCardNumber) {


            var cardType;
            for (var propt in _cardFormatDefinition) {

                /* range */

                for (var i = 0; i &lt; _cardFormatDefinition[propt][&quot;ranges&quot;].length; i++) {
                    if (_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;] != null) {

                        for (var j = 0; j &lt; _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;]; j++) {
                            var startNumber = _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;] + j;
                            if (creditCardNumber.indexOf(startNumber) === 0) {

                                serviceCreditCard.idType = propt;
                                cardType = propt;


                                break;
                            } else {

                            }
                        }
                    } else {

                        if (creditCardNumber.indexOf(_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;]) === 0) {
                            serviceCreditCard.idType = propt;
                            cardType = propt;
                            break;
                        }
                    }
                }
                /* ./ range */
            }

            return cardType;

        };


        serviceCreditCard.initInfoCardWithCardNumber = function(creditCardNumber) {

            if (creditCardNumber == undefined) {
                creditCardNumber = document.getElementById(_idInputMapper.cardNumber).value;
            }


            if (document.getElementById(_idInputMapper.cardType)) {
                // document.getElementById(_idInputMapper.cardType).src = undefined;
                document.getElementById(_idInputMapper.cardType).src = &quot;&quot;;
                document.getElementById(_idInputMapper.cardType).setAttribute(&#x27;style&#x27;, &#x27;display:none;&#x27;);
            }
            for (var propt in _cardFormatDefinition) {

                /* range */

                for (var i = 0; i &lt; _cardFormatDefinition[propt][&quot;ranges&quot;].length; i++) {
                    if (_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;] != null) {

                        for (var j = 0; j &lt; _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;]; j++) {
                            var startNumber = _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;] + j;
                            if (creditCardNumber.indexOf(startNumber) === 0) {

                                // document.getElementById(_idInputMapper.cardType).innerHTML = propt;

                                serviceCreditCard.idType = propt;
                                // document.getElementById(_idInputMapper.cardType).innerHTML = &#x27;&lt;img width=&quot;28px&quot; src=&quot;./img/type/&#x27; + _cardImg[propt] + &#x27;&quot;&gt;&#x27;;
                                document.getElementById(_idInputMapper.cardType).src = &quot;./img/type/&quot; + _cardImg[propt];
                                document.getElementById(_idInputMapper.cardType).setAttribute(&#x27;style&#x27;,&#x27;display:block;&#x27;);


                                serviceCreditCard.cardFormatArray = _cardFormatDefinition[propt][&quot;format&quot;];
                                /* length */
                                serviceCreditCard.cardLengthMin = serviceCreditCard.cardLengthMax = _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;length&quot;];
                                if (_cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;] != null) {
                                    serviceCreditCard.cardLengthMax = serviceCreditCard.cardLengthMin + _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;];
                                }
                                /* ./ length */

                                break;
                            } else {

                            }
                        }
                    } else {

                        if (creditCardNumber.indexOf(_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;]) === 0) {
                            // document.getElementById(_idInputMapper.cardType).innerHTML = propt;
                            serviceCreditCard.idType = propt;
                            // document.getElementById(_idInputMapper.cardType).innerHTML = &#x27;&lt;img width=&quot;28px&quot; src=&quot;./img/type/&#x27; + _cardImg[propt] + &#x27;&quot;&gt;&#x27;;

                            document.getElementById(_idInputMapper.cardType).src = &quot;./img/type/&quot; + _cardImg[propt];
                            document.getElementById(_idInputMapper.cardType).setAttribute(&#x27;style&#x27;,&#x27;display:block;&#x27;);


                            serviceCreditCard.cardFormatArray = _cardFormatDefinition[propt][&quot;format&quot;];
                            /* length */
                            serviceCreditCard.cardLengthMin = serviceCreditCard.cardLengthMax = _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;length&quot;];
                            if (_cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;] != null) {
                                serviceCreditCard.cardLengthMax = serviceCreditCard.cardLengthMin + _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;];
                            }

                            /* ./ length */
                            break;
                        }
                    }
                }
                /* ./ range */
            }

        };




        serviceCreditCard.unformatCreditCardNumber = function(cardNumberStringFormatted) {
            if (cardNumberStringFormatted != undefined) {
                return cardNumberStringFormatted.split(&#x27; &#x27;).join(&#x27;&#x27;);
            }
            return cardNumberStringFormatted;
        }
        // var _inputCCFinish = function(element, cardNumberString, cardLengthMin, cardLengthMax) {
        var _inputCCNumberFinish = function(element) {

            var validatorCreditCardNumber = serviceCreditCard.validatorCreditCardNumber([]);





            // document.getElementById(&quot;creditCardNumberMessageContainer&quot;).innerHTML=&quot;&quot;;
            // document.getElementById(_idInputMapper.cardNumber).setAttribute(&#x27;style&#x27;, &#x27;color:&#x27;+ _colorInput[&quot;default&quot;] + &#x27; !important&#x27;);
            document.getElementById(_idInputMapper.cardCVV).disabled = false;
            if ( serviceCreditCard.cardNumberStringFormatAfter != &#x27;&#x27;) {

                // if maestro cvc disabled

                if (serviceCreditCard.idType == &#x27;card_maestro_info&#x27;) {

                    var cvvElement =  document.getElementById(_idInputMapper.cardCVV);
                    cvvElement.value = &quot;&quot;;
                    // cvvElement.setAttribute(&#x27;style&#x27;, &#x27;color:#333333 !important&#x27;);


                    if (!cvvElement.classList.contains(&#x27;inputdisabled&#x27;)) {
                        // The box that we clicked has a class of bad so let&#x27;s remove it and add the good class
                        // this.classList.remove(&#x27;bad&#x27;);
                        cvvElement.classList.add(&#x27;inputdisabled&#x27;);
                    } else {
                        cvvElement.classList.remove(&#x27;inputdisabled&#x27;);
                        // The user obviously can&#x27;t follow instructions so let&#x27;s alert them of what is supposed to happen next

                    }


                    // inputdisable
                    cvvElement.disabled = true;

                }

            }
            if(serviceCreditCard.cardNumberStringFormatAfter != &#x27;&#x27; &amp;&amp; validatorCreditCardNumber.isValid( document.getElementById(_idInputMapper.cardNumber).value)) {
                _focusNextElement();
                // element.focus();
            }
            else {
                if (serviceCreditCard.cardLengthMax == serviceCreditCard.cardNumberStringAfter.length &amp;&amp; !validatorCreditCardNumber.isValid(document.getElementById(_idInputMapper.cardNumber).value)) {



                    // validatorCreditCardNumber.displayErrorMessage()

                    //  document.getElementById(&quot;creditCardNumberMessageContainer&quot;).innerHTML=&quot;Le format de la carte n&#x27;est pas valide&quot;;
                    //  document.bgColor = _colorInput[&quot;error&quot;];
                    // document.getElementById(_idInputMapper.cardNumber).setAttribute(&#x27;style&#x27;, &#x27;color:&#x27;+ _colorInput[&quot;error&quot;] + &#x27; !important&#x27;);

                }
            }
        };

        var _inputCardExpiryDateFinish = function(element) {

            var validatorCreditCardExpiryDate = serviceCreditCard.validatorCreditCardExpiryDate([]);


var lengthCardExpiry = 4 + _separatorMonthYear.length;
            // alert(lengthCardExpiry);

            if ( lengthCardExpiry == document.getElementById(_idInputMapper.cardExpiryDate).value.length &amp;&amp; validatorCreditCardExpiryDate.isValid( document.getElementById(_idInputMapper.cardExpiryDate).value) === true ) {


                // element.focus();
                _focusNextElement();
            } else {
                if (7 == document.getElementById(_idInputMapper.cardExpiryDate).value.length &amp;&amp; validatorCreditCardExpiryDate.isValid(document.getElementById(_idInputMapper.cardExpiryDate).value) === false) {


                }
            }
        };


        serviceCreditCard.validatorCreditCardNumber = function(errorArray) {
            var validatorCreditCardNumber = {};





            validatorCreditCardNumber.errorCollection = errorArray || [];


            validatorCreditCardNumber.isPotentiallyValid = function(creditCardNumber) {

                var isPotentiallyValid = false;
                var startNumberArray = [];
                for (var propt in _cardFormatDefinition) {

                    /* range */
                    for (var i = 0; i &lt; _cardFormatDefinition[propt][&quot;ranges&quot;].length; i++) {
                        if (_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;] != null) {

                            for (var j = 0; j &lt; _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;]; j++) {
                                startNumberArray.push([_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;] + j, propt]);
                            }




                        } else {
                            startNumberArray.push([_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;], propt]);

                        }
                    }
                    /* ./ range */
                }



                var startNumber;
                var startNumberToCompare;


                var cardNumberMaxLength = 23;

                var propt;
                for (var indexNumber = 0; indexNumber &lt; startNumberArray.length; indexNumber++) {


                    startNumber = startNumberArray[indexNumber][0].toString();
                    propt = startNumberArray[indexNumber][1].toString();
                    startNumberToCompare = startNumber.substr(0,Math.min(startNumber.length, creditCardNumber.length));
                    if (creditCardNumber.indexOf(startNumberToCompare) === 0) {


                        cardNumberMaxLength = _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;length&quot;];
                        if (_cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;] != null) {
                            cardNumberMaxLength = cardNumberMaxLength + _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;];
                        }


                        if(creditCardNumber.length &lt; cardNumberMaxLength) {
                            isPotentiallyValid = true;
                            break;
                        } else if(creditCardNumber.length == cardNumberMaxLength) {
                            if (_isLuhnValid(creditCardNumber) === true) {
                                isPotentiallyValid = true;
                                break;
                            }
                        }
                    }
                }

                if (serviceCreditCard.getCardTypeId() != undefined &amp;&amp; _isEnabled(serviceCreditCard.getCardTypeId()) === false) {
                    isPotentiallyValid = false;
                }



                if (isPotentiallyValid == false) {
                    validatorCreditCardNumber.isValid(creditCardNumber);
                }
                return isPotentiallyValid;
            }













            validatorCreditCardNumber.isValid = function (creditCardNumberUnformatted) {

                // var value = serviceCreditCard.cardNumberStringFormatAfter;

                // var creditCardNumberUnformated = serviceCreditCard.cardNumberStringAfter.split(&#x27; &#x27;).join(&#x27;&#x27;);

                if (creditCardNumberUnformatted != undefined) {

                    creditCardNumberUnformatted = creditCardNumberUnformatted.split(&#x27; &#x27;).join(&#x27;&#x27;);
                }






                if (_isEnabled(serviceCreditCard.getCardTypeId()) === false) {
                    validatorCreditCardNumber.errorCollection.push(new _InvalidParametersError(50,  _getLocaleTranslationWithId(&#x27;FORM_ERROR_INVALID_CARD_NUMBER&#x27;)));


                    document.getElementById(_idInputMapper.cardType).setAttribute(&#x27;style&#x27;,&#x27;display:none;&#x27;);


                    return false;
                }

                if (_isTypeValid(serviceCreditCard.getCardTypeId()) === false) {
                    validatorCreditCardNumber.errorCollection.push(new _InvalidParametersError(50,  _getLocaleTranslationWithId(&#x27;FORM_ERROR_INVALID_CARD_NUMBER&#x27;)));
                    return false;
                }


                if (/[^0-9-\s]+/.test(creditCardNumberUnformatted)) {
                    validatorCreditCardNumber.errorCollection.push(new _InvalidParametersError(50,  _getLocaleTranslationWithId(&#x27;FORM_ERROR_INVALID_CARD_NUMBER&#x27;)));
                    return false;
                }



                if (_isLengthValid(creditCardNumberUnformatted) === false) {
                    validatorCreditCardNumber.errorCollection.push(new _InvalidParametersError(50,  _getLocaleTranslationWithId(&#x27;FORM_ERROR_INVALID_CARD_NUMBER&#x27;)));
                    return false;
                }

                if (_isLuhnValid(creditCardNumberUnformatted) === false) {
                    validatorCreditCardNumber.errorCollection.push(new _InvalidParametersError(50,  _getLocaleTranslationWithId(&#x27;FORM_ERROR_INVALID_CARD_NUMBER&#x27;)));
                    return false;
                }

                return true;
            };

            var _isEnabled = function(cardTypeId) {

                if (_availableAndEnabledPaymentProductsCollection.length == 0) {
                    _initAvailableAndEnabledPaymentProductsCollection();
                }


                if (_availableAndEnabledPaymentProductsCollection.length == 0) {
                    return true;
                } else {
                    for (indexEnableProduct in _availableAndEnabledPaymentProductsCollection) {
                        if (_idProductAPIMapper[_availableAndEnabledPaymentProductsCollection[indexEnableProduct]] == cardTypeId) {
                            return true;
                        }
                    }
                }

                return false;

            }

            var _isTypeValid =function(cardTypeId) {
                if (_cardFormatDefinition.hasOwnProperty(cardTypeId) === false) {
                    return false;
                }
            }

            var _isLengthValid = function (value) {
                if (value.length &lt; serviceCreditCard.cardLengthMin || (serviceCreditCard.cardLengthMax != null &amp;&amp; value.length &gt; serviceCreditCard.cardLengthMax) ) {
                    return false;
                }
                return true;
            }

            var _isLuhnValid = function (value) {
                // The Luhn Algorithm. It&#x27;s so pretty.
                var nCheck = 0, nDigit = 0, bEven = false;
                value = value.replace(/\D/g, &quot;&quot;);

                for (var n = value.length - 1; n &gt;= 0; n--) {
                    var cDigit = value.charAt(n),
                        nDigit = parseInt(cDigit, 10);

                    if (bEven) {
                        if ((nDigit *= 2) &gt; 9) nDigit -= 9;
                    }

                    nCheck += nDigit;
                    bEven = !bEven;
                }

                return (nCheck % 10) == 0;

            };
            return validatorCreditCardNumber;
        };

        serviceCreditCard.validatorCreditCardHolder = function(errorArray) {
            var validatorCreditCardHolder = {};


            validatorCreditCardHolder.errorCollection = errorArray || [];

            validatorCreditCardHolder.isValid = function (creditCardHolderString) {
                if (creditCardHolderString == &quot;&quot; || creditCardHolderString == undefined || creditCardHolderString == null) {
                    return false;
                }

                if (creditCardHolderString.length &gt; serviceCreditCard.creditCardHolderLengthMax ) {
                    return false;
                }
                return true;
            }


            validatorCreditCardHolder.isPotentiallyValid = function(creditCardHolderString) {

                var isPotentiallyValid = false;

                if (creditCardHolderString.length &lt;= serviceCreditCard.creditCardHolderLengthMax ) {
                    isPotentiallyValid = true;
                }


                return isPotentiallyValid;
            }

            return validatorCreditCardHolder;

        };

        /**
         *
         * @param errorCollection
         * @returns {{}}
         * @constructor
         */
        serviceCreditCard.validatorCreditCardExpiryDate = function (errorCollection) {

            var validatorExpiryDate = {};
            validatorExpiryDate.errorCollection = errorCollection || [];

            validatorExpiryDate.isPotentiallyValid = function(creditCardExpiryDate) {
                var isPotentiallyValid = false;



                var splitExpiryDate = creditCardExpiryDate.split(_separatorMonthYear);

                if (splitExpiryDate.length &lt; 2) {

                    if (splitExpiryDate &lt;= 12) {
                        isPotentiallyValid = true;
                    }
                } else {

                    if (splitExpiryDate.length == 2) {
                        var month = splitExpiryDate[0];
                        var year = splitExpiryDate[1];
                        if (year.length &lt; 2) {

                            if (month &lt;= 12 &amp;&amp; year &gt;= 1) {
                                isPotentiallyValid = true;
                            }
                        } else {

                            // Return today&#x27;s date and time
                            var currentTime = new Date();

                            // returns the month (from 0 to 11)
                            var currentMonth = currentTime.getMonth() + 1;

                            // returns the year (four digits)
                            var currentYear = currentTime.getFullYear();

                            var yearYYYY = &quot;20&quot; + year;
                            if(yearYYYY &gt; currentYear &amp;&amp; yearYYYY &lt;= (currentYear + _maxYearExpiry)) {
                                isPotentiallyValid = true;
                            } else if(yearYYYY == currentYear &amp;&amp; month &gt;= currentMonth) {
                                isPotentiallyValid = true;
                            }



                        }


                    }
                }



                if (isPotentiallyValid == false) {
                    validatorExpiryDate.isValid(creditCardExpiryDate);
                }


                return isPotentiallyValid;

            };

            validatorExpiryDate.isValid = function(creditCardExpiryDate) {

                if (creditCardExpiryDate == undefined) {
                    creditCardExpiryDate = document.getElementById(_idInputMapper.cardExpiryDate).value;
                }
                var splitExpiryDate = creditCardExpiryDate.split(_separatorMonthYear);
                if (splitExpiryDate.length != 2) {
                    validatorExpiryDate.errorCollection.push(new _InvalidParametersError(50, &#x27;format de date non valide&#x27;));
                    return false;
                }

                var month = splitExpiryDate[0];
                var year = splitExpiryDate[1];

                // Return today&#x27;s date and time
                var currentTime = new Date();

                // returns the month (from 0 to 11)
                var currentMonth = currentTime.getMonth() + 1;

                // returns the year (four digits)
                var currentYear = currentTime.getFullYear();


                year = &quot;20&quot; + year;

                if(month &gt; 12) {
                    validatorExpiryDate.errorCollection.push(new _InvalidParametersError(50, _getLocaleTranslationWithId(&quot;FORM_ERROR_INVALID_MONTH_EXPIRY_DATE&quot;)));
                    return false;
                } else if(year &lt; currentYear || year &gt; (currentYear + _maxYearExpiry)) {
                    validatorExpiryDate.errorCollection.push(new _InvalidParametersError(50, _getLocaleTranslationWithId(&quot;FORM_ERROR_INVALID_EXPIRY_DATE_PAST&quot;)));
                    return false;
                }
                else if(year == currentYear &amp;&amp; month &lt; currentMonth || year &lt; currentYear) {
                    validatorExpiryDate.errorCollection.push(new _InvalidParametersError(50, _getLocaleTranslationWithId(&quot;FORM_ERROR_INVALID_EXPIRY_DATE_PAST&quot;)));
                    return false;
                }
                return true;
            };

            return validatorExpiryDate;


        };

        serviceCreditCard.validatorCreditCardCVV = function(errorArray,validateAll) {
            var validatorCreditCardCVV = {};



            validatorCreditCardCVV.errorCollection = errorArray || [];





            validatorCreditCardCVV.isPotentiallyValid = function (creditCardCVVString,creditCardNumber) {


                var isPotentiallyValid = false;

                var arrayFormatCVV = [&#x27;34&#x27;, &#x27;35&#x27;, &#x27;36&#x27;, &#x27;37&#x27;];
                for (var indexFormatCVV = 0; indexFormatCVV &lt;= arrayFormatCVV.length;indexFormatCVV++ ) {

                    if (document.getElementById(_idInputMapper.cardNumber).value != &quot;&quot; &amp;&amp; creditCardNumber.indexOf(arrayFormatCVV[indexFormatCVV]) === 0) {
                        serviceCreditCard.creditCardCVVLengthMax = 4;
                    }
                }



                if (creditCardCVVString != &quot;&quot; &amp;&amp; creditCardCVVString.length &lt;= serviceCreditCard.creditCardCVVLengthMax ) {
                    isPotentiallyValid = true;
                }

                if (serviceCreditCard.idType == &#x27;card_maestro_info&#x27; &amp;&amp; creditCardCVVString == &quot;&quot;) {
                    isPotentiallyValid = true;
                }

                if (isPotentiallyValid == false) {
                    validatorCreditCardCVV.isValid(creditCardCVVString);
                }


                return isPotentiallyValid;
            };


            validatorCreditCardCVV.isValid = function (creditCardCVVString) {

                if (serviceCreditCard.idType == &#x27;card_maestro_info&#x27;) {
                    return true;
                }



                if (creditCardCVVString == &quot;&quot; || creditCardCVVString == undefined || creditCardCVVString == null) {
                    return false;
                }

                // cvv amex

                var creditCardNumber = document.getElementById(_idInputMapper.cardNumber).value;
                var arrayFormatCVV = [&#x27;34&#x27;,&#x27;35&#x27;,&#x27;36&#x27;,&#x27;37&#x27;];
                for (var indexFormatCVV = 0; indexFormatCVV &lt;= arrayFormatCVV.length;indexFormatCVV++ ) {

                    if (document.getElementById(_idInputMapper.cardNumber).value != &quot;&quot; &amp;&amp; creditCardNumber.indexOf(arrayFormatCVV[indexFormatCVV]) === 0) {
                        serviceCreditCard.creditCardCVVLengthMax = 4;
                    }
                }



                if (creditCardCVVString.length &gt; serviceCreditCard.creditCardCVVLengthMax ) {
                    // validatorCreditCardCVV.errorCollection.push(new _InvalidParametersError(50, &#x27;Le champ CVC doit contenir &#x27;+serviceCreditCard.creditCardCVVLengthMax+&#x27; digits&#x27;));





                    validatorCreditCardCVV.errorCollection.push(new _InvalidParametersError(50, _getLocaleTranslationWithId(&quot;FORM_ERROR_INVALID_CVV&quot;).replace(&quot;%NUMBER%&quot;, serviceCreditCard.creditCardCVVLengthMax)));
                    return false;
                }


                if ((validateAll == undefined || validateAll == true) &amp;&amp; creditCardCVVString.length &lt; serviceCreditCard.creditCardCVVLengthMax ) {
                    // validatorCreditCardCVV.errorCollection.push(new _InvalidParametersError(50, &#x27;Le champ CVC doit contenir &#x27;+serviceCreditCard.creditCardCVVLengthMax+&#x27; digits&#x27;));
                    validatorCreditCardCVV.errorCollection.push(new _InvalidParametersError(50, _getLocaleTranslationWithId(&quot;FORM_ERROR_INVALID_CVV&quot;).replace(&quot;%NUMBER%&quot;, serviceCreditCard.creditCardCVVLengthMax)));

                    return false;
                }




                return true;
            };

            return validatorCreditCardCVV;

        };

        serviceCreditCard.validatorCreditCard = function(errorCollection) {

            var validatorCreditCard = {};
            // validatorCreditCard.errorCollection = errorCollection;
            validatorCreditCard.errorCollection = [];


            validatorCreditCard.isValid = function(params) {

                var hasError = false;
                var validatorCreditCardNumber = serviceCreditCard.validatorCreditCardNumber();
                if (!validatorCreditCardNumber.isValid(serviceCreditCard.unformatCreditCardNumber(params[&#x27;card_number&#x27;]))) {
                    validatorCreditCard.errorCollection[&#x27;creditCardNumber&#x27;] = validatorCreditCardNumber.errorCollection;
                    hasError = true;
                    // return false;
                }

                var validatorCreditCardHolder = serviceCreditCard.validatorCreditCardHolder(validatorCreditCard.errorCollection);
                if (!validatorCreditCardHolder.isValid(params[&#x27;card_holder&#x27;])) {

                    hasError = true;
                    // return false;
                }

                var validatorCreditCardExpiryDate = serviceCreditCard.validatorCreditCardExpiryDate(validatorCreditCard.errorCollection);
                if (!validatorCreditCardExpiryDate.isValid(params[&#x27;card_expiry_date&#x27;])) {
                    hasError = true;
                    // return false;
                }

                var validatorCreditCardCVV = serviceCreditCard.validatorCreditCardCVV(validatorCreditCard.errorCollection);
                if (!validatorCreditCardCVV.isValid(params[&#x27;cvc&#x27;])) {
                    hasError = true;
                    // return false;
                }

                if (hasError) {
                    return false;
                }

                // document.getElementById(&quot;creditCardExpiryDateMessageContainer&quot;).innerHTML=validatorCreditCardExpiryDate.errorCollection[0][&#x27;message&#x27;];



                return true;
            };



            return validatorCreditCard;




        };

        serviceCreditCard.initCreditCardNumber = function(charCode, stringPaste){

            serviceCreditCard.lastCharCode = charCode;

            if (charCode == undefined || charCode == &#x27;&#x27; || charCode == 8 || charCode == 46) {
                serviceCreditCard.lastCharString = &#x27;&#x27;;
            }
            else {
                serviceCreditCard.lastCharString = String.fromCharCode(charCode);
            }

            if (serviceCreditCard.lastCharString === &#x27;&#x27;) {

            }

            serviceCreditCard.cardNumberStringFormatBefore = document.getElementById(_idInputMapper.cardNumber).value;
            serviceCreditCard.cardNumberStringFormatedBefore = document.getElementById(_idInputMapper.cardNumber).value;


            //realposition cursor in number
            var splitFormatBeforetemp = serviceCreditCard.cardNumberStringFormatBefore;
            serviceCreditCard.cardNumberStringUnformatedBefore = splitFormatBeforetemp.split(&#x27; &#x27;).join(&#x27;&#x27;);

            var getStartEndCursor = _getSelection(document.getElementById(_idInputMapper.cardNumber));

            // position avant action avec formatage.
            var startBFormat = getStartEndCursor.start;
            var endBFormat = getStartEndCursor.end;

            // calcul des positions de curseur sans formatage :
            // si espace(s) entre debut et position curseur =&gt; on soustrait le nb d&#x27;espaces

            var subStringStart =  serviceCreditCard.cardNumberStringFormatedBefore.substr(0, startBFormat);
            var splitSubStringStart = subStringStart.split(&#x27; &#x27;);
            var nbSpaceStart = splitSubStringStart.length - 1;

            var subStringEnd =  serviceCreditCard.cardNumberStringFormatedBefore.substr(0, endBFormat);
            var splitSubStringEnd = subStringEnd.split(&#x27; &#x27;);
            var nbSpaceEnd = splitSubStringEnd.length - 1;

            var startB = parseInt(startBFormat) - parseInt(nbSpaceStart);
            var endB = parseInt(endBFormat) - parseInt(nbSpaceEnd);


            var startA = startB;
            var endA = endB;

            // string after

            var newTempStringAfter = serviceCreditCard.cardNumberStringUnformatedBefore;



            if (stringPaste) {

                // delete all chars but number
                var stringPaste = stringPaste.replace(/[^0-9]/g, &#x27;&#x27;);

                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {

                    newTempStringAfter = newTempStringAfter.substring(0, startB) + stringPaste + newTempStringAfter.substring(endB, newTempStringAfter.length);
                    endA = stringPaste.length;

                } else if (startB &gt;= 0) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + stringPaste + newTempStringAfter.substring(startB, newTempStringAfter.length);
                    endA = stringPaste.length;
                }

                if (newTempStringAfter.length &gt;= 25) {
                    newTempStringAfter =newTempStringAfter.substring(0,25);
                }



            } else {


                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {


                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + newTempStringAfter.substring(endB, newTempStringAfter.length);
                    endA = startA;
                    // realCursorPositionInNumberAfter = realCursorPositionInNumberBefore;

                }
                else if (startB &gt; 0) {
                    if (charCode == 8) {

                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB) - 1));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB)), newTempStringAfter.length);

                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                        startA = startA - 1;

                    } else if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;


                    }
                    endA = startA;
                } else if (startB == 0) {
                    if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;


                    }
                    endA = startA;
                }
            }



            var tempStringAfter = &quot;&quot;;


            var startAtemp = startA;
            for (var nbBefore = 0; nbBefore &lt;= newTempStringAfter.length;nbBefore++ ) {


                if (nbBefore == startA) {


                    if (charCode == 8 || charCode == 46) {

                    } else {
                        if (stringPaste) {
                            startAtemp = startAtemp + stringPaste.length;
                        } else {
                            tempStringAfter += serviceCreditCard.lastCharString;
                            startAtemp = startAtemp + 1;
                        }


                    }


                }

                tempStringAfter += newTempStringAfter.charAt(nbBefore);

            }
            startA = startAtemp;


// formatage du numero

            serviceCreditCard.cardLengthMin = 0;
            serviceCreditCard.cardLengthMax = 25;

            serviceCreditCard.idType = null;



            for (var propt in _cardFormatDefinition) {

                /* range */

                for (var i = 0; i &lt; _cardFormatDefinition[propt][&quot;ranges&quot;].length; i++) {
                    if (_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;] != null) {

                        for (var j = 0; j &lt; _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;variable&quot;]; j++) {
                            var startNumber = _cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;] + j;
                            if (tempStringAfter.indexOf(startNumber) === 0) {

                                // document.getElementById(_idInputMapper.cardType).innerHTML = propt;

                                serviceCreditCard.idType = propt;



                                // document.getElementById(_idInputMapper.cardType).innerHTML = &#x27;&lt;img width=&quot;28px&quot; src=&quot;./img/type/&#x27; + _cardImg[propt] + &#x27;&quot;&gt;&#x27;;




                                var my_elem = document.getElementById(_idInputMapper.cardNumber);

                                // var span = document.createElement(&#x27;img&#x27;);
                                //
                                // span.className = &#x27;asterisk&#x27;;
                                //
                                // my_elem.parentNode.insertBefore(span, my_elem);






                                serviceCreditCard.cardFormatArray = _cardFormatDefinition[propt][&quot;format&quot;];
                                /* length */
                                serviceCreditCard.cardLengthMin = serviceCreditCard.cardLengthMax = _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;length&quot;];
                                if (_cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;] != null) {
                                    serviceCreditCard.cardLengthMax = serviceCreditCard.cardLengthMin + _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;];
                                }
                                /* ./ length */

                                break;
                            } else {

                            }
                        }
                    } else {

                        if (tempStringAfter.indexOf(_cardFormatDefinition[propt][&quot;ranges&quot;][i][&quot;first&quot;]) === 0) {
                            // document.getElementById(_idInputMapper.cardType).innerHTML = propt;
                            serviceCreditCard.idType = propt;

                            // document.getElementById(_idInputMapper.cardType).innerHTML = &#x27;&lt;img width=&quot;28px&quot; src=&quot;./img/type/&#x27; + _cardImg[propt] + &#x27;&quot;&gt;&#x27;;








                            serviceCreditCard.cardFormatArray = _cardFormatDefinition[propt][&quot;format&quot;];
                            /* length */
                            serviceCreditCard.cardLengthMin = serviceCreditCard.cardLengthMax = _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;length&quot;];
                            if (_cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;] != null) {
                                serviceCreditCard.cardLengthMax = serviceCreditCard.cardLengthMin + _cardFormatDefinition[propt][&quot;lengths&quot;][&quot;variable&quot;];
                            }

                            /* ./ length */
                            break;
                        }
                    }
                }
                /* ./ range */
            }

            if (serviceCreditCard.cardLengthMax == null || tempStringAfter.length &lt;= serviceCreditCard.cardLengthMax) {
                serviceCreditCard.cardNumberStringAfter = tempStringAfter;
            }
            else {

                if (stringPaste) {
                    serviceCreditCard.cardNumberStringAfter = tempStringAfter.substr(0,serviceCreditCard.cardLengthMax);
                } else {
                    serviceCreditCard.cardNumberStringAfter = serviceCreditCard.cardNumberStringUnformatedBefore;
                    startA = startB;
                }
            }


            var numberFormatTotal = 0;

            var tempForStringAfter = &quot;&quot;;
            if ( serviceCreditCard.cardFormatArray.length &gt; 0) {
                var positionSpaceArray = [];
                var startFormat = 0;
                for (var i = 0; i &lt; serviceCreditCard.cardFormatArray.length; i++) {


                    positionSpaceArray[(startFormat + serviceCreditCard.cardFormatArray[i])] = 1;
                    startFormat += serviceCreditCard.cardFormatArray[i];

                }


            }


            // var deltaCursorAfterFormat = 0;
            var numberSpaceBeforeStartFormated= 0;
            for (var nb=0; nb&lt; serviceCreditCard.cardNumberStringAfter.length;nb++) {
                //
                //
                if (positionSpaceArray != undefined &amp;&amp; positionSpaceArray[nb]===1) {

                    if (nb &lt; startA) {
                        numberSpaceBeforeStartFormated +=1;
                    }
                    tempForStringAfter += &#x27; &#x27;;


                }
                tempForStringAfter += serviceCreditCard.cardNumberStringAfter.charAt(nb);
            }

            serviceCreditCard.cardNumberStringFormatAfter = tempForStringAfter;

            var startAFormat = startA + numberSpaceBeforeStartFormated;



            document.getElementById(_idInputMapper.cardNumber).value = serviceCreditCard.cardNumberStringFormatAfter;
            _setCaretPosition(document.getElementById(_idInputMapper.cardNumber), startAFormat);


            // focus next input + change color input on error

            _inputCCNumberFinish( document.getElementById(_idInputMapper.cardHolder), serviceCreditCard);




            // })(charCode);
        };

        serviceCreditCard.initCreditCardHolder = function(charCode){

            serviceCreditCard.lastCharCodeCreditCardHolder = charCode;
            if (charCode == undefined || charCode == &#x27;&#x27; || charCode == 8 || charCode == 46) {
                serviceCreditCard.lastCharStringCreditCardHolder = &#x27;&#x27;;
            }
            else {
                serviceCreditCard.lastCharStringCreditCardHolder = String.fromCharCode(charCode);
            }

            serviceCreditCard.cardHolderStringFormatedBefore = document.getElementById(_idInputMapper.cardHolder).value;

            var getStartEndCursor = _getSelection(document.getElementById(_idInputMapper.cardHolder));

            // position avant action avec formatage.
            var startBFormat = getStartEndCursor.start;
            var endBFormat = getStartEndCursor.end;

            // calcul des positions de curseur sans formatage :
            // si espace(s) entre debut et position curseur =&gt; on soustrait le nb d&#x27;espaces

            var subStringStart =  serviceCreditCard.cardHolderStringFormatedBefore.substr(0, startBFormat);


            var subStringEnd =  serviceCreditCard.cardHolderStringFormatedBefore.substr(0, endBFormat);


            var startB = parseInt(startBFormat);
            var endB = parseInt(endBFormat);


            var startA = startB;
            var endA = endB;

            // string after

            var newTempStringAfter = serviceCreditCard.cardHolderStringFormatedBefore;

            if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {

                newTempStringAfter = newTempStringAfter.substring(0,startB) + &quot;&quot; + newTempStringAfter.substring(endB, newTempStringAfter.length);
                endA = startA;
                // realCursorPositionInNumberAfter = realCursorPositionInNumberBefore;

            }
            else if (startB &gt; 0) {
                if(charCode == 8) {

                    var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB) - 1));
                    var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB)), newTempStringAfter.length);
                    // dump(tempStringAfterDebut);
                    // dump(tempStringAfterFin);
                    newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                    startA = startA - 1;

                } else if(charCode == 46) {
                    var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                    var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                    newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                }
                endA = startA;
            } else if(startB == 0) {
                if(charCode == 46) {
                    var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                    var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                    newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;


                }
                endA = startA;
            }



            var startA = startBFormat;

            var tempStringAfter = &quot;&quot;;


            var startAtemp = startA;
            for (var nbBefore = 0; nbBefore &lt;= newTempStringAfter.length;nbBefore++ ) {

                // if (nbBefore == realCursorPositionInNumberBefore) {
                if (nbBefore == startA) {


                    if (charCode == 8 || charCode == 46) {

                    } else {
                        tempStringAfter += serviceCreditCard.lastCharStringCreditCardHolder;
                        // realCursorPositionInNumberAfter = realCursorPositionInNumberBefore + 1;
                        startAtemp = startAtemp + 1;


                    }


                }

                tempStringAfter += newTempStringAfter.charAt(nbBefore);

            }
            startA = startAtemp;



            if (serviceCreditCard.creditCardHolderLengthMax == null || tempStringAfter.length &lt;= serviceCreditCard.creditCardHolderLengthMax) {
                serviceCreditCard.cardHolderStringAfter = tempStringAfter;
            }
            else {
                serviceCreditCard.cardHolderStringAfter = serviceCreditCard.cardHolderStringFormatedBefore;
                startA = startBFormat;
            }


            document.getElementById(_idInputMapper.cardHolder).value = serviceCreditCard.cardHolderStringAfter;
            _setCaretPosition(document.getElementById(_idInputMapper.cardHolder), startA);





            // })(charCode);
        };




        serviceCreditCard.initCreditCardExpiryDate = function(charCode, stringPaste){



            serviceCreditCard.lastCharCodeCreditCardExpiryDate = charCode;
            if (charCode == undefined || charCode == &#x27;&#x27; || charCode == 8 || charCode == 46) {
                serviceCreditCard.lastCharStringCreditCardExpiryDate = &#x27;&#x27;;
            }
            else {
                serviceCreditCard.lastCharStringCreditCardExpiryDate = String.fromCharCode(charCode);
            }

            serviceCreditCard.creditCardExpiryDateFormattedBefore = document.getElementById(_idInputMapper.cardExpiryDate).value;







            //realposition cursor in number
            var splitFormatBeforetemp = serviceCreditCard.creditCardExpiryDateFormattedBefore;
            serviceCreditCard.creditCardExpiryDateUnformattedBefore = splitFormatBeforetemp.split(_separatorMonthYear).join(&#x27;&#x27;);




            var getStartEndCursor = _getSelection(document.getElementById(_idInputMapper.cardExpiryDate));

            // position avant action avec formatage.
            var startBFormat = getStartEndCursor.start;
            var endBFormat = getStartEndCursor.end;




            // calcul des positions de curseur sans formatage :
            // si espace(s) entre debut et position curseur =&gt; on soustrait le nb d&#x27;espaces

            var subStringStart =  serviceCreditCard.creditCardExpiryDateFormattedBefore.substr(0, startBFormat);

            var splitSubStringStart = subStringStart.split(_separatorMonthYear);
            var nbSpaceStart = (splitSubStringStart.length - 1)*_separatorMonthYear.length;


            var subStringEnd =  serviceCreditCard.creditCardExpiryDateFormattedBefore.substr(0, endBFormat);


            var splitSubStringEnd = subStringEnd.split(_separatorMonthYear);
            var nbSpaceEnd = (splitSubStringEnd.length - 1)*_separatorMonthYear.length;

            var startB = parseInt(startBFormat) - parseInt(nbSpaceStart);
            var endB = parseInt(endBFormat) - parseInt(nbSpaceEnd);

            var startA = startB;
            var endA = endB;

            var newTempStringAfter = serviceCreditCard.creditCardExpiryDateUnformattedBefore;






            if (stringPaste) {


                // delete all chars but number
                var stringPaste = stringPaste.replace(/[^0-9]/g, &#x27;&#x27;);

                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + stringPaste + newTempStringAfter.substring(endB, newTempStringAfter.length);
                    endA = stringPaste.length;
                } else if (startB &gt;= 0) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + stringPaste + newTempStringAfter.substring(startB, newTempStringAfter.length);
                    endA = stringPaste.length;
                }

                if (newTempStringAfter.length &gt;= 4) {
                    newTempStringAfter =newTempStringAfter.substring(0,4);
                }

            } else {
                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + newTempStringAfter.substring(endB, newTempStringAfter.length);
                    endA = startA;

                }
                else if (startB &gt; 0) {
                    if (charCode == 8) {

                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB) - 1));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB)), newTempStringAfter.length);

                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                        startA = startA - 1;

                    } else if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                    }
                    endA = startA;
                } else if (startB == 0) {
                    if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;


                    }
                    endA = startA;
                }
            }

            var tempStringAfter = &quot;&quot;;
            var startAtemp = startA;


            for (var nbBefore = 0; nbBefore &lt;= newTempStringAfter.length;nbBefore++ ) {
                if (nbBefore == startA) {
                    if (charCode == 8 || charCode == 46) {
                    } else {
                        tempStringAfter += serviceCreditCard.lastCharStringCreditCardExpiryDate;
                        startAtemp = startAtemp + 1;
                    }
                }

                tempStringAfter += newTempStringAfter.charAt(nbBefore);
            }
            startA = startAtemp;

            if (tempStringAfter.length &lt;= 4) {
                serviceCreditCard.cardExpiryDateStringAfter = tempStringAfter;
            }
            else {
                serviceCreditCard.cardExpiryDateStringAfter = serviceCreditCard.creditCardExpiryDateFormattedBefore;
                startA = startBFormat;
            }

            serviceCreditCard.cardExpiryDateStringFormattedAfter =  serviceCreditCard.cardExpiryDateStringAfter;
            if ( serviceCreditCard.cardExpiryDateStringFormattedAfter.length === 1) {
                if (serviceCreditCard.cardExpiryDateStringFormattedAfter.charAt(0) &gt; 1) {
                    serviceCreditCard.cardExpiryDateStringFormattedAfter = &quot;0&quot;+serviceCreditCard.cardExpiryDateStringFormattedAfter;
                    startA = startA + 1;
                }
            }

            if ( serviceCreditCard.cardExpiryDateStringFormattedAfter.length &gt;= 2) {

                if (serviceCreditCard.cardExpiryDateStringFormattedAfter.split(_separatorMonthYear).length &lt; 2) {
                    serviceCreditCard.cardExpiryDateStringFormattedAfter = serviceCreditCard.cardExpiryDateStringFormattedAfter.substring(0, 2) + _separatorMonthYear + serviceCreditCard.cardExpiryDateStringFormattedAfter.substring(2, serviceCreditCard.cardExpiryDateStringFormattedAfter.length);
                    startA = startA + _separatorMonthYear.length;
                }
            }

            document.getElementById(_idInputMapper.cardExpiryDate).value = serviceCreditCard.cardExpiryDateStringFormattedAfter;
            _setCaretPosition(document.getElementById(_idInputMapper.cardExpiryDate), startA);
            _inputCardExpiryDateFinish( document.getElementById(_idInputMapper.cardCVV), serviceCreditCard);

        };


        serviceCreditCard.initCreditCardCVV = function(charCode, stringPaste){

            serviceCreditCard.lastCharCodeCreditCardCVV = charCode;
            if (charCode == undefined || charCode == &#x27;&#x27; || charCode == 8 || charCode == 46) {
                serviceCreditCard.lastCharStringCreditCardCVV = &#x27;&#x27;;
            }
            else {
                serviceCreditCard.lastCharStringCreditCardCVV = String.fromCharCode(charCode);
            }

            serviceCreditCard.cardCVVStringFormatedBefore = document.getElementById(_idInputMapper.cardCVV).value;

            var getStartEndCursor = _getSelection(document.getElementById(_idInputMapper.cardCVV));

            // position avant action avec formatage.
            var startBFormat = getStartEndCursor.start;
            var endBFormat = getStartEndCursor.end;

            // calcul des positions de curseur sans formatage :
            // si espace(s) entre debut et position curseur =&gt; on soustrait le nb d&#x27;espaces

            var subStringStart =  serviceCreditCard.cardCVVStringFormatedBefore.substr(0, startBFormat);


            var subStringEnd =  serviceCreditCard.cardCVVStringFormatedBefore.substr(0, endBFormat);


            var startB = parseInt(startBFormat);
            var endB = parseInt(endBFormat);


            var startA = startB;
            var endA = endB;

            // string after

            var newTempStringAfter = serviceCreditCard.cardCVVStringFormatedBefore;

            if (stringPaste) {
                // delete all chars but number
                stringPaste = stringPaste.replace(/[^0-9]/g, &#x27;&#x27;);

                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + stringPaste + newTempStringAfter.substring(endB, newTempStringAfter.length);
                } else if (startB &gt;= 0) {

                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + stringPaste + newTempStringAfter.substring(startB, newTempStringAfter.length);
                    endA = stringPaste.length;
                }
                var startBFormat = startB + stringPaste.length;


                if (newTempStringAfter.length &gt;= 4) {
                    newTempStringAfter =newTempStringAfter.substring(0,4);
                }
            } else {

                if (startB &gt;= 0 &amp;&amp; endB &gt; 0 &amp;&amp; startB &lt; endB) {
                    newTempStringAfter = newTempStringAfter.substring(0, startB) + &quot;&quot; + newTempStringAfter.substring(endB, newTempStringAfter.length);
                    endA = startA;
                }
                else if (startB &gt; 0) {
                    if (charCode == 8) {

                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB) - 1));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB)), newTempStringAfter.length);

                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                        startA = startA - 1;

                    } else if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;

                    }
                    endA = startA;
                } else if (startB == 0) {
                    if (charCode == 46) {
                        var tempStringAfterDebut = newTempStringAfter.substring(0, (parseInt(startB)));
                        var tempStringAfterFin = newTempStringAfter.substring((parseInt(startB) + 1), newTempStringAfter.length);
                        newTempStringAfter = tempStringAfterDebut + &quot;&quot; + tempStringAfterFin;
                    }
                    endA = startA;
                }
            }

            var startA = startBFormat;
            var tempStringAfter = &quot;&quot;;
            var startAtemp = startA;
            for (var nbBefore = 0; nbBefore &lt;= newTempStringAfter.length;nbBefore++ ) {
                if (nbBefore == startA) {
                    if (charCode == 8 || charCode == 46) {
                    } else {
                        tempStringAfter += serviceCreditCard.lastCharStringCreditCardCVV;
                        // realCursorPositionInNumberAfter = realCursorPositionInNumberBefore + 1;
                        startAtemp = startAtemp + 1;
                    }
                }
                tempStringAfter += newTempStringAfter.charAt(nbBefore);
            }
            startA = startAtemp;

            var arrayFormatCVV = [&#x27;34&#x27;,&#x27;35&#x27;,&#x27;36&#x27;,&#x27;37&#x27;];
            var creditCardNumber = document.getElementById(_idInputMapper.cardNumber).value;
            for (var indexFormatCVV = 0; indexFormatCVV &lt;= arrayFormatCVV.length;indexFormatCVV++ ) {
                if (creditCardNumber.value != &quot;&quot; &amp;&amp; creditCardNumber.indexOf(arrayFormatCVV[indexFormatCVV]) === 0) {
                    serviceCreditCard.creditCardCVVLengthMax = 4;
                }
            }

            if (serviceCreditCard.creditCardCVVLengthMax == null || tempStringAfter.length &lt;= serviceCreditCard.creditCardCVVLengthMax) {
                serviceCreditCard.cardCVVStringAfter = tempStringAfter;
            }
            else {
                if (stringPaste) {
                    serviceCreditCard.cardCVVStringAfter = tempStringAfter.substr(0,serviceCreditCard.creditCardCVVLengthMax);
                    // startA = stringPaste.length;
                } else {
                    serviceCreditCard.cardCVVStringAfter = serviceCreditCard.cardCVVStringFormatedBefore;
                    startA = startBFormat;
                }
            }

            document.getElementById(_idInputMapper.cardCVV).value = serviceCreditCard.cardCVVStringAfter;
            _setCaretPosition(document.getElementById(_idInputMapper.cardCVV), startA);

        };
        return serviceCreditCard;
    }

    /**
     *
     */
    var _callbackEventFormChange = new Function();

    /**
     *
     * @private
     */
    var _initErrorHandler = function(e){

        // var evt = e || window.event;



        // _callbackEventFormChange();
        for (var indexInput in _idInputMapper) {
            if (indexInput != &quot;cardType&quot;) {

                if (document.getElementById(_idInputMapper[indexInput]) != null &amp;&amp; document.getElementById(_idInputMapper[indexInput]).classList.contains(&#x27;error-card-form&#x27;)) {
                    document.getElementById(_idInputMapper[indexInput]).classList.remove(&#x27;error-card-form&#x27;);
                }
                if (document.getElementById(_idInputMapper[indexInput]) != null &amp;&amp; !document.getElementById(_idInputMapper[indexInput]).classList.contains(&#x27;default-card-form&#x27;)) {
                    document.getElementById(_idInputMapper[indexInput]).classList.add(&#x27;default-card-form&#x27;);
                }
                // document.getElementById(_idInputMapper[indexInput]).setAttribute(&#x27;style&#x27;, &#x27;color:&#x27; + _colorInput[&quot;default&quot;] + &#x27; !important&#x27;);
            }
        }

        var errors = HiPay.Form.paymentFormDataGetErrors();

        for (var indexError in errors) {
            if (document.getElementById(_idInputMapper[indexInput]) != null &amp;&amp; !document.getElementById(_idInputMapper[indexInput]).classList.contains(&#x27;error-card-form&#x27;)) {
                // The box that we clicked has a class of bad so let&#x27;s remove it and add the good class
                document.getElementById(_idInputMapper[indexError]).classList.add(&#x27;error-card-form&#x27;);
            }
            if (document.getElementById(_idInputMapper[indexInput]) != null &amp;&amp; document.getElementById(_idInputMapper[indexError]).classList.contains(&#x27;default-card-form&#x27;)) {
                document.getElementById(_idInputMapper[indexError]).classList.remove(&#x27;default-card-form&#x27;);
            }


            // document.getElementById(_idInputMapper[indexError]).setAttribute(&#x27;style&#x27;, &#x27;color:#ff0000 !important&#x27;);

        }
    };

    /**
     *
     * @param idElement
     * @param s
     * @param fn
     * @private
     */
    var _addListenerMulti = function (idElement, s, fn) {
        var eventList = s.split(&#x27; &#x27;);
        for(var eventIndex = 0; eventIndex &lt; eventList.length; eventIndex++) {
            if (document.getElementById(idElement) != null) {
                document.getElementById(idElement).addEventListener(eventList[eventIndex], function (e) {
                    fn();
                }, false);
            }
        }
    };

    /**
     *
     * @param idElement
     * @private
     */
    var _initListenEvent = function(idElement){
        _addListenerMulti(idElement, &#x27;keydown keypress blur focus&#x27;, _initErrorHandler);
    };



    // var _replacePlaceholderLikeBlur = function(idElement, stringPlaceholderLike) {
    //     if (document.getElementById(idElement).value == &quot;&quot;) {
    //         document.getElementById(idElement).value = stringPlaceholderLike;
    //     }
    //
    // }
    // var _replacePlaceholderLikeFocus = function(idElement, stringPlaceholderLike) {
    //     if (document.getElementById(idElement).value == stringPlaceholderLike) {
    //         document.getElementById(idElement).value = &quot;&quot;;
    //     }
    //
    // }

    var _initPlaceholder = function() {
        for (var propt in _idInputMapper) {

            if (document.getElementById(_idInputMapper[propt]) != null &amp;&amp; document.getElementById(_idInputMapper[propt]).placeholder == &quot;&quot;) {
                switch (propt) {
                    case &#x27;cardNumber&#x27;:
                        document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;);
                        break;
                    case &#x27;cardHolder&#x27;:
                        document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_HOLDER&quot;);
                        break;
                    case &#x27;cardExpiryDate&#x27;:
                        document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_EXPIRY_DATE&quot;);
                        break;
                    case &#x27;cardCVV&#x27;:
                        document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_CVV&quot;);
                        break;
                }
            } else {
                // console.log(&#x27;no placeholder&#x27;);
                // switch (propt) {
                //     case &#x27;cardNumber&#x27;:
                //         document.getElementById(_idInputMapper[propt]).value = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;);
                //         if (document.getElementById(_idInputMapper[propt]).attachEvent) {
                //             document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onblur&quot;, _replacePlaceholderLikeBlur(_idInputMapper[propt],_getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)));
                //             document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onfocus&quot;, _replacePlaceholderLikeFocus(_idInputMapper[propt],_getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)));
                //         } else {
                //             document.getElementById(_idInputMapper[propt]).addEventListener (&quot;blur&quot;, _replacePlaceholderLikeBlur(_idInputMapper[propt], _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)), false);  // all browsers and IE9+
                //             document.getElementById(_idInputMapper[propt]).addEventListener (&quot;focus&quot;, _replacePlaceholderLikeFocus(_idInputMapper[propt], _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)), false);  // all browsers and IE9+
                //         }
                //
                //
                //         break;
                //     case &#x27;cardHolder&#x27;:
                //         document.getElementById(_idInputMapper[propt]).value = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_HOLDER&quot;);
                //         if (document.getElementById(_idInputMapper[propt]).attachEvent) {
                //             document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onblur&quot;, _replacePlaceholderLikeBlur(_idInputMapper[propt],_getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)));
                //             document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onfocus&quot;, _replacePlaceholderLikeFocus(_idInputMapper[propt],_getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)));
                //         } else {
                //             document.getElementById(_idInputMapper[propt]).addEventListener (&quot;blur&quot;, _replacePlaceholderLikeBlur(_idInputMapper[propt], _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)), false);  // all browsers and IE9+
                //             document.getElementById(_idInputMapper[propt]).addEventListener (&quot;focus&quot;, _replacePlaceholderLikeFocus(_idInputMapper[propt], _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_NUMBER&quot;)), false);  // all browsers and IE9+
                //         }
                //         break;
                //     case &#x27;cardExpiryDate&#x27;:
                //         document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_EXPIRY_DATE&quot;);
                //         break;
                //     case &#x27;cardCVV&#x27;:
                //         document.getElementById(_idInputMapper[propt]).placeholder = _getLocaleTranslationWithId(&quot;FORM_PLACEHOLDER_CARD_CVV&quot;);
                //         break;
                // }


            }
        }
    };



    /* add listener on all input form */
    window.onload = function() {

        // HiPay.Form.setLocale(&quot;en_EN&quot;);

        // create ico card type
        // card type
        var my_elem = document.getElementById(_idInputMapper.cardNumber);

        var imgType = document.createElement(&#x27;img&#x27;);
        // span.innerHTML = &#x27;*&#x27;;
        imgType.className = &#x27;asterisk&#x27;;
        imgType.id = _idInputMapper[&#x27;cardType&#x27;];
        imgType.src = undefined;
        imgType.setAttribute(&#x27;style&#x27;,&#x27;display:none;&#x27;);

        my_elem.parentNode.insertBefore(imgType, my_elem.nextSibling);

        // add placeholder
        _initPlaceholder();


        for(var propt in _idInputMapper){


            if (propt == &#x27;cardNumber&#x27;) {


                // var handlerInput = function(e) {
                //     console.log(&#x27;oninput&#x27;);
                //         var evt = e || window.event;
                //         var charCode = evt.keyCode || evt.which;
                //         if (charCode == 8 || charCode == 46) {
                //
                //             // _instanceServiceCreditCard = new _serviceCreditCard(charCode);
                //             _instanceServiceCreditCard = new _serviceCreditCard();
                //             _instanceServiceCreditCard.initCreditCardNumber(charCode);
                //             evt.preventDefault();
                //             // _callbackEventFormChange();
                //         } else {
                //             // evt.preventDefault();
                //         }
                //
                //         _callbackEventFormChange();
                //
                //     // _callbackEventFormChange();
                // };
                //
                // if (document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent) {
                //     document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent(&quot;oninput&quot;, handlerInput);
                // } else {
                //     document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener (&quot;input&quot;, handlerInput, false);  // all browsers and IE9+
                // }




                // keydown

                // document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener(&#x27;keydown&#x27;, function (e) {

                var handlerKeydown = function(e) {
                    evt = e || window.event;
                    var charCode = evt.keyCode || evt.which;
                    if (charCode == 8 || charCode == 46) {

                        // _instanceServiceCreditCard = new _serviceCreditCard(charCode);
                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardNumber(charCode);
                        evt.preventDefault();
                        // _callbackEventFormChange();
                    } else {
                        // evt.preventDefault();
                    }

                    _callbackEventFormChange();

                    // HiPay.Form.paymentFormDataGetErrors();

                };
                // });



                if (document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent) {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent(&quot;onkeydown&quot;, handlerKeydown);
                } else {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener (&quot;keydown&quot;, handlerKeydown, false);  // all browsers and IE9+
                }

                // ./ keydown



                // paste
                var handlerPaste = function(e) {

                    var evt = e || window.event;

                    var pastedText = &quot;&quot;;
                    if (window.clipboardData) {
                        pastedText = window.clipboardData.getData(&#x27;Text&#x27;);

                    } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                        pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);
                    }

                    evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);

                    _instanceServiceCreditCard = new _serviceCreditCard();
                    _instanceServiceCreditCard.initCreditCardNumber(&quot;&quot;,pastedText);

                    _callbackEventFormChange();
                };
                if (document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent) {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent(&quot;onpaste&quot;, handlerPaste);
                } else {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener (&quot;paste&quot;, handlerPaste, false);  // all browsers and IE9+
                }

                // ./ paste

                document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener(&#x27;keypress&#x27;, function (e) {
                    // return false;
                    evt = e || window.event;


                    var charCode = evt.keyCode || evt.which;

                    evt.preventDefault();
                    if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                        /* is valid add char */
                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardNumber(charCode);
                    }

                    _callbackEventFormChange();

                });


                var handlerInput = function(e) {


                    //

                    var evt = e || window.event;
                    //
                    // var pastedText = &quot;&quot;;
                    // if (window.clipboardData) {
                    //     pastedText = window.clipboardData.getData(&#x27;Text&#x27;);
                    //
                    // } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                    //     pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);
                    // }
                    //
                    evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);

                    _instanceServiceCreditCard = new _serviceCreditCard();
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).focus();

                    // document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).value = &quot;&quot;;
                    // document.getElementById(_idInputMapper[&#x27;cardExpiryDate&#x27;]).value = &quot;&quot;;
                    _instanceServiceCreditCard.initCreditCardNumber(&quot;&quot;,document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).value);




                    // var expDateFormat = document.getElementById(&quot;cardExpirationMonth&quot;).value + &#x27; / &#x27; + document.getElementById(&quot;cardExpirationYear&quot;).value.substr(2,4);
// alert(expDateFormat);

                    _callbackEventFormChange();
                };

                if (document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent) {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).attachEvent(&quot;onchange&quot;, handlerInput);
                } else {
                    document.getElementById(_idInputMapper[&#x27;cardNumber&#x27;]).addEventListener (&quot;change&quot;, handlerInput, false);  // all browsers and IE9+
                }









                _initListenEvent(_idInputMapper[propt]);

            }
            else if (propt == &#x27;cardHolder&#x27;) {

                document.getElementById(_idInputMapper[propt]).addEventListener(&#x27;keydown&#x27;, function (e) {


                    evt = e || window.event;

                    var charCode = evt.keyCode || evt.which;
                    if (charCode == 8 || charCode == 46) {
                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardHolder(charCode);
                        evt.preventDefault();

                    } else {


                    }
                    _callbackEventFormChange();




                });

                document.getElementById(_idInputMapper[propt]).addEventListener(&#x27;keypress&#x27;, function (e) {

                    evt = e || window.event;

                    var charCode = evt.keyCode || evt.which;

                    if (charCode == 8 || charCode == 46) {

                    } else {

                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardHolder(charCode);
                        evt.preventDefault();
                    }
                    _callbackEventFormChange();
                });



            }
            else if (propt == &#x27;cardExpiryDate&#x27;) {

                document.getElementById(_idInputMapper[propt]).addEventListener(&#x27;keydown&#x27;, function (e) {


                    evt = e || window.event;

                    var charCode = evt.keyCode || evt.which;
                    if (charCode == 8 || charCode == 46) {
                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardExpiryDate(charCode);
                        evt.preventDefault();
                    } else {

                    }
                    _callbackEventFormChange();



                });

                document.getElementById(_idInputMapper[propt]).addEventListener(&#x27;keypress&#x27;, function (e) {

                    evt = e || window.event;

                    var charCode = evt.keyCode || evt.which;
                    evt.preventDefault();
                    if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {

                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardExpiryDate(charCode);

                    }
                    _callbackEventFormChange();
                });


                // paste
                var handlerExpiryDate = function(e) {
                    var evt = e || window.event;

                    var pastedText = &quot;&quot;;
                    if (window.clipboardData) {
                        pastedText = window.clipboardData.getData(&#x27;Text&#x27;);
                    } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                        pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);

                    }

                    evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);

                    _instanceServiceCreditCard = new _serviceCreditCard();
                    _instanceServiceCreditCard.initCreditCardExpiryDate(&quot;&quot;,pastedText);

                    _callbackEventFormChange();
                };
                if (document.getElementById(_idInputMapper[propt]).attachEvent) {
                    document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onpaste&quot;, handlerExpiryDate);
                } else {
                    document.getElementById(_idInputMapper[propt]).addEventListener (&quot;paste&quot;, handlerExpiryDate, false);  // all browsers and IE9+
                }

                // ./ paste




            }

            else if (propt == &#x27;cardCVV&#x27;) {

                document.getElementById(_idInputMapper[&#x27;cardCVV&#x27;]).addEventListener(&#x27;keydown&#x27;, function (e) {
                    var evt = e || window.event;

                    var charCode = evt.keyCode || evt.which;
                    if (charCode == 8 || charCode == 46) {
                        // _instanceServiceCreditCard = new _serviceCreditCard(charCode);
                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardCVV(charCode);
                        evt.preventDefault();

                    }
                    _callbackEventFormChange();
                });

                document.getElementById(_idInputMapper[&#x27;cardCVV&#x27;]).addEventListener(&#x27;keypress&#x27;, function (e) {

                    var evt = e || window.event;


                    var charCode = evt.keyCode || evt.which;

                    evt.preventDefault();
                    if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                        /* is valid add char */

                        _instanceServiceCreditCard = new _serviceCreditCard();
                        _instanceServiceCreditCard.initCreditCardCVV(charCode);
                    }
                    _callbackEventFormChange();
                });


                // paste
                var handlerExpiryDatePaste = function(e) {
                    var evt = e || window.event;

                    var pastedText = &quot;&quot;;
                    if (window.clipboardData) {
                        pastedText = window.clipboardData.getData(&#x27;Text&#x27;);

                    } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                        pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);
                    }

                    evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);

                    _instanceServiceCreditCard = new _serviceCreditCard();
                    _instanceServiceCreditCard.initCreditCardCVV(&quot;&quot;,pastedText);

                    _callbackEventFormChange();
                };
                if (document.getElementById(_idInputMapper[propt]).attachEvent) {
                    document.getElementById(_idInputMapper[propt]).attachEvent(&quot;onpaste&quot;, handlerExpiryDatePaste);
                } else {
                    document.getElementById(_idInputMapper[propt]).addEventListener (&quot;paste&quot;, handlerExpiryDatePaste, false);  // all browsers and IE9+
                }
                // ./ paste



                // document.getElementById(_idInputMapper[&#x27;cardCVV&#x27;]).addEventListener(&#x27;blur&#x27;, function (e) {
                //     _instanceServiceCreditCard = new _serviceCreditCard();
                //     var validatorCreditCardCVV = _instanceServiceCreditCard.validatorCreditCardCVV();
                // });
            }

            else if(propt == &#x27;cardExpirationMonth&#x27;) {


                var handlerScanExpiry = function(e) {


                    //

                    var evt = e || window.event;
                    //
                    // var pastedText = &quot;&quot;;
                    // if (window.clipboardData) {
                    //     pastedText = window.clipboardData.getData(&#x27;Text&#x27;);
                    //
                    // } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                    //     pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);
                    // }
                    //
                    // evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);


                    if (document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value != &quot;&quot; &amp;&amp; document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value != &quot;&quot;) {
                        var expDateFormat = document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value + &#x27; / &#x27; + document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value.substr(2, 4);


                        _instanceServiceCreditCard = new _serviceCreditCard();
                        document.getElementById(_idInputMapper[&#x27;cardExpiryDate&#x27;]).focus();
                        document.getElementById(_idInputMapper[&#x27;cardExpiryDate&#x27;]).value = &quot;&quot;;


                        _instanceServiceCreditCard.initCreditCardExpiryDate(&quot;&quot;, expDateFormat);
                        document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value = &quot;&quot;;
                        document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value = &quot;&quot;;
                        _callbackEventFormChange();
                    }
                };


                if (document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).attachEvent) {
                    document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).attachEvent(&quot;onchange&quot;, handlerScanExpiry);
                } else {
                    document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).addEventListener (&quot;change&quot;, handlerScanExpiry, false);  // all browsers and IE9+
                }

            } else if(propt == &#x27;cardExpirationYear&#x27;) {

                var handlerScanExpiry = function(e) {


                    //

                    var evt = e || window.event;
                    //
                    // var pastedText = &quot;&quot;;
                    // if (window.clipboardData) {
                    //     pastedText = window.clipboardData.getData(&#x27;Text&#x27;);
                    //
                    // } else if(evt.clipboardData &amp;&amp; evt.clipboardData.getData) {
                    //     pastedText = e.clipboardData.getData(&#x27;text/plain&#x27;);
                    // }
                    //
                    // evt.preventDefault ? evt.preventDefault() : (evt.returnValue = false);


                    if (document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value != &quot;&quot; &amp;&amp; document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value != &quot;&quot;) {
                        var expDateFormat = document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value + &#x27; / &#x27; + document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value.substr(2, 4);


                        _instanceServiceCreditCard = new _serviceCreditCard();
                        document.getElementById(_idInputMapper[&#x27;cardExpiryDate&#x27;]).focus();
                        document.getElementById(_idInputMapper[&#x27;cardExpiryDate&#x27;]).value = &quot;&quot;;

                        _instanceServiceCreditCard.initCreditCardExpiryDate(&quot;&quot;, expDateFormat);
                        document.getElementById(_idInputMapper[&#x27;cardExpirationMonth&#x27;]).value = &quot;&quot;;
                        document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).value = &quot;&quot;;


                        _callbackEventFormChange();
                    }
                };



                if (document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).attachEvent) {
                    document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).attachEvent(&quot;onchange&quot;, handlerScanExpiry);
                } else {
                    document.getElementById(_idInputMapper[&#x27;cardExpirationYear&#x27;]).addEventListener (&quot;change&quot;, handlerScanExpiry, false);  // all browsers and IE9+
                }
            }
            else {





            }

            // document.getElementById(_idInputMapper[propt]).addEventListener(&#x27;blur&#x27;, function (e) {
            //     _callbackEventFormChange();
            //
            // });
            _initListenEvent(_idInputMapper[propt]);

        }


    };

    /**
     *
     * @returns {{card_number, card_expiry_month: string, card_expiry_year: string, card_holder, cvv, multi_use: string, generate_request_id: string}}
     * @private
     */
    var _getParamsFromForm = function() {
        var creditCardExpiryDate = document.getElementById(_idInputMapper.cardExpiryDate).value;


        var explodeExpiryDate = creditCardExpiryDate.split(_separatorMonthYear);



        var month = &quot;&quot;;
        var year = &quot;&quot;;
        if (explodeExpiryDate.length == 2) {
            month = explodeExpiryDate[0];


            year = explodeExpiryDate[1];

        } else {
            month = explodeExpiryDate[0];
        }
        return  {
            card_number: document.getElementById(_idInputMapper.cardNumber).value,
            card_expiry_month: month,
            card_expiry_year: year,
            card_holder: document.getElementById(_idInputMapper.cardHolder).value,
            cvv: document.getElementById(_idInputMapper.cardCVV).value,
            multi_use: &#x27;0&#x27;,
            generate_request_id: &#x27;0&#x27;
        };
    };

    /**
     *
     * @returns {{type: *, length: *}}
     */


    /**
     * CVV information by card (name and length of CVV)
     * @method HiPay.getCVVInformation
     * @return {object}
     */
    HiPay.getCVVInformation = function() {
        _instanceServiceCreditCard = new _serviceCreditCard();

        var CVVLength = _instanceServiceCreditCard.getCreditCardCVVLengthMax();
        if (CVVLength == undefined) {
            CVVLength = 3;
        }

        var idType = _instanceServiceCreditCard.getTypeWithCardNumber(_instanceServiceCreditCard.getCreditCardNumberValue());
        return {type:_idCVVMapper[idType],
            length: CVVLength};
    }

    /**
     * Get errors in form
     *
     * @method HiPay.Form.paymentFormDataGetErrors
     * @return errorCollection
     */
    HiPay.Form.paymentFormDataGetErrors = function() {

        _instanceServiceCreditCard = new _serviceCreditCard();
        var validatorCreditCard = _instanceServiceCreditCard.validatorCreditCard();
        var params = _getParamsFromForm();
        var errorCollection = {};
        var hasError = false;
        // Credit card number
        var validatorCreditCardNumber = _instanceServiceCreditCard.validatorCreditCardNumber();
        var creditCardNumberUnformatted = _instanceServiceCreditCard.unformatCreditCardNumber(params[&#x27;card_number&#x27;]);

        if (creditCardNumberUnformatted != &quot;&quot;) {

            if (!validatorCreditCardNumber.isPotentiallyValid(creditCardNumberUnformatted) ||
                (!validatorCreditCardNumber.isValid(creditCardNumberUnformatted) &amp;&amp; document.getElementById(_idInputMapper.cardNumber) !== document.activeElement )
            ) {
                errorCollection[&#x27;cardNumber&#x27;] = validatorCreditCardNumber.errorCollection[0][&#x27;message&#x27;];
            }
        }




        // Credit card holder
        var validatorCreditCardHolder = _instanceServiceCreditCard.validatorCreditCardHolder();
        var creditCardHolderString = params[&#x27;card_holder&#x27;];

        if (creditCardHolderString != &quot;&quot;) {
            if (!validatorCreditCardHolder.isPotentiallyValid(creditCardHolderString) ||
                (!validatorCreditCardHolder.isValid(creditCardHolderString) &amp;&amp; document.getElementById(_idInputMapper.cardHolder) !== document.activeElement )
            ) {
                errorCollection[&#x27;cardHolder&#x27;] = validatorCreditCardHolder.errorCollection[0][&#x27;message&#x27;];
            }
        }

        // Credit card expiry date
        var validatorCreditCardExpiryDate = _instanceServiceCreditCard.validatorCreditCardExpiryDate();
        var creditCardExpiryDateString = params[&#x27;card_expiry_month&#x27;];
        if (params[&#x27;card_expiry_year&#x27;] != &quot;&quot;) {
            creditCardExpiryDateString +=  _separatorMonthYear + params[&#x27;card_expiry_year&#x27;];
        }

        if (creditCardExpiryDateString != &quot;&quot;) {
            if (!validatorCreditCardExpiryDate.isPotentiallyValid(creditCardExpiryDateString) ||
                (!validatorCreditCardExpiryDate.isValid(creditCardExpiryDateString) &amp;&amp; document.getElementById(_idInputMapper.cardExpiryDate) !== document.activeElement )
            ) {
                errorCollection[&#x27;cardExpiryDate&#x27;] = validatorCreditCardExpiryDate.errorCollection[0][&#x27;message&#x27;];
            }
        }



// Credit card security code
        var validatorCreditCardCVV = _instanceServiceCreditCard.validatorCreditCardCVV();
        var creditCardCVVString = params[&#x27;cvv&#x27;];
        if (creditCardCVVString != &quot;&quot;) {
            if (!validatorCreditCardCVV.isPotentiallyValid(creditCardCVVString,creditCardNumberUnformatted) ||
                (!validatorCreditCardCVV.isValid(creditCardCVVString) &amp;&amp; document.getElementById(_idInputMapper.cardCVV) !== document.activeElement )
            ) {
                errorCollection[&#x27;cardCVV&#x27;] = validatorCreditCardCVV.errorCollection[0][&#x27;message&#x27;];
            }
        }


        return errorCollection;

    };

    /**
     * Callback on form change
     *
     * @method HiPay.Form.change
     * @parameter {function} callback
     *
     */
    HiPay.Form.change = function(callback) {
        _callbackEventFormChange = callback;
    };

    /**
     * Is valid form data.
     *
     * @method HiPay.Form.paymentFormDataIsValid
     * @return {Boolean} Form is or is not valid
     *
     */
    HiPay.Form.paymentFormDataIsValid = function() {


        var params = {
            card_number: $(&#x27;#input-card&#x27;)[0].value,
            card_holder: $(&#x27;#input-name&#x27;)[0].value,
            cvc: $(&#x27;#input-cvv&#x27;)[0].value,
            card_expiry_date: $(&#x27;#input-expiry-date&#x27;)[0].value,

            multi_use: &#x27;0&#x27;
        };


        if (!_instanceServiceCreditCard) {

            _instanceServiceCreditCard = new _serviceCreditCard();
        }

        var validatorCreditCard = _instanceServiceCreditCard.validatorCreditCard();

        return validatorCreditCard.isValid(params);
    }

    /**
     *
     * @param instance
     * @param payload
     * @param specialValueCallback
     * @private
     */
    var _processObjectPayload = function (instance, payload, specialValueCallback) {
        var propertyConfig = [];

        for (var key in payload || {}) {

            if (typeof instance._mapping === &#x27;object&#x27;) {

                var mapping = instance._mapping[key];

                if (typeof mapping === &#x27;object&#x27;) {
                    value = typeof specialValueCallback !== &#x27;undefined&#x27; ? (specialValueCallback(key, payload[key]) || payload[key]) : payload[key];

                    // Property is writable, value can directly be set
                    if (!_canDefineProperty || mapping.propertyDescriptors.writable) {
                        instance[mapping.name] = value;
                    }

                    // Property not writable, should be redefined
                    else {
                        propertyConfig[mapping.name] =_extend({}, mapping.propertyDescriptors, {
                            value: value,
                            configurable: true // Values might be refreshed later
                        });

                    }
                }
            }
        }

        if (_canDefineProperty) {
            Object.defineProperties(instance, propertyConfig);
        }
    };

    // IE classlist
    if(Object.defineProperty &amp;&amp; isIE() &lt; 10) {
        Object.defineProperty(Element.prototype, &#x27;classList&#x27;, {
            // _defineProperties(Element.prototype, &#x27;classList&#x27;, {
            get: function () {
                var self = this, bValue = self.className.split(&quot; &quot;)

                bValue.add = function () {
                    var b;
                    for (i in arguments) {
                        b = true;
                        for (var j = 0; j &lt; bValue.length; j++)
                            if (bValue[j] == arguments[i]) {
                                b = false
                                break
                            }
                        if (b)
                            self.className += (self.className ? &quot; &quot; : &quot;&quot;) + arguments[i]
                    }
                }
                bValue.remove = function () {
                    self.className = &quot;&quot;
                    for (i in arguments)
                        for (var j = 0; j &lt; bValue.length; j++)
                            if (bValue[j] != arguments[i])
                                self.className += (self.className ? &quot; &quot; : &quot;&quot;) + bValue[j]
                }
                bValue.toggle = function (x) {
                    var b;
                    if (x) {
                        self.className = &quot;&quot;
                        b = false;
                        for (var j = 0; j &lt; bValue.length; j++)
                            if (bValue[j] != x) {
                                self.className += (self.className ? &quot; &quot; : &quot;&quot;) + bValue[j]
                                b = false
                            } else b = true
                        if (!b)
                            self.className += (self.className ? &quot; &quot; : &quot;&quot;) + x
                    } else throw new TypeError(&quot;Failed to execute &#x27;toggle&#x27;: 1 argument required&quot;)
                    return !b;
                }
                bValue.contains = function () {
                    var b;
                    for (i in arguments) {
                        b = false;
                        for (var j = 0; j &lt; bValue.length; j++)
                            if (bValue[j] == arguments[i]) {
                                b = true
                                break
                            }

                        return b;
                    }
                }

                return bValue;
            },
            enumerable: true,
            configurable: true
        });

    }




    /**
     *
     * @type {{APIIncorrectCredentials: number, APIIncorrectSignature: number, APIAccountNotActive: number, APIAccountLocked: number, APIInsufficientPermissions: number, APIForbiddenAccess: number, APIUnsupportedVersion: number, APITemporarilyUnavailable: number, APINotAllowed: number, APIMethodNotAllowedGateway: number, APIInvalidParameter: number, APIMethodNotAllowedSecureVault: number, APIInvalidCardToken: number, APIRequiredParameterMissing: number, APIInvalidParameterFormat: number, APIInvalidParameterLength: number, APIInvalidParameterNonAlpha: number, APIInvalidParameterNonNum: number, APIInvalidParameterNonDecimal: number, APIInvalidDate: number, APIInvalidTime: number, APIInvalidIPAddress: number, APIInvalidEmailAddress: number, APIInvalidSoftDescriptorCodeMessage: number, APINoRouteToAcquirer: number, APIUnsupportedECIDescription: number, APIUnsupported: number, APIUnknownOrder: number, APIUnknownTransaction: number, APIUnknownMerchant: number, APIUnsupportedOperation: number, APIUnknownIPAddress: number, APISuspicionOfFraud: number, APIFraudSuspicion: number, APIUnknownToken: number, APILuhnCheckFailed: number, APIUnsupportedCurrency: number, APIAmountLimitExceeded: number, APIMaxAttemptsExceeded: number, APIDuplicateOrder: number, APICheckoutSessionExpired: number, APIOrderCompleted: number, APIOrderExpired: number, APIOrderVoided: number, APIAuthorizationExpired: number, APIAllowableAmountLimitExceeded: number, APINotEnabled: number, APINotAllowedCapture: number, APINotAllowedPartialCapture: number, APIPermissionDenied: number, APICurrencyMismatch: number, APIAuthorizationCompleted: number, APINoMore: number, APIInvalidAmount: number, APIAmountLimitExceededCapture: number, APIAmountLimitExceededPartialCapture: number, APIOperationNotPermittedClosed: number, APIOperationNotPermittedFraud: number, APIRefundNotEnabled: number, APIRefundNotAllowed: number, APIPartialRefundNotAllowed: number, APIRefundPermissionDenied: number, APIRefundCurrencyMismatch: number, APIAlreadyRefunded: number, APIRefundNoMore: number, APIRefundInvalidAmount: number, APIRefundAmountLimitExceeded: number, APIRefundAmountLimitExceededPartial: number, APIOperationNotPermitted: number, APITooLate: number, APIReauthorizationNotEnabled: number, APIReauthorizationNotAllowed: number, APICannotReauthorize: number, APIMaxLimitExceeded: number, APIVoidNotAllowed: number, APICannotVoid: number, APIAuthorizationVoided: number, APIDeclinedAcquirer: number, APIDeclinedFinancialInstituion: number, APIInsufficientFundsAccount: number, APITechnicalProblem: number, APICommunicationFailure: number, APIAcquirerUnavailable: number, APIDuplicateTransaction: number, APIPaymentCancelledByTheCustomer: number, APIInvalidTransaction: number, APIPleaseCallTheAcquirerSupportCallNumber: number, APIAuthenticationFailedPleaseRetryOrCancel: number, APINoUIDConfiguredForThisOperation: number, APIRefusalNoExplicitReason: number, APIIssuerNotAvailable: number, APIInsufficientFundsCredit: number, APITransactionNotPermitted: number, APIInvalidCardNumber: number, APIUnsupportedCard: number, APICardExpired: number, APIExpiryDateIncorrect: number, APICVCRequired: number, APICVCError: number, APIAVSFailed: number, APIRetainCard: number, APILostOrStolenCard: number, APIRestrictedCard: number, APICardLimitExceeded: number, APICardBlacklisted: number, APIUnauthorisedIPAddressCountry: number, APICardnotInAuthorisersDatabase: number}}
     */
    HiPay.ErrorReason = {
        APIIncorrectCredentials: 1000001,
        APIIncorrectSignature: 1000002,
        APIAccountNotActive: 1000003,
        APIAccountLocked: 1000004,
        APIInsufficientPermissions: 1000005,
        APIForbiddenAccess: 1000006,
        APIUnsupportedVersion: 1000007,
        APITemporarilyUnavailable: 1000008,
        APINotAllowed: 1000009,
        APIMethodNotAllowedGateway: 1010001,
        APIInvalidParameter: 1010002,
        APIMethodNotAllowedSecureVault: 1010003,
        APIInvalidCardToken: 1012003,
        APIRequiredParameterMissing: 1010101,
        APIInvalidParameterFormat: 1010201,
        APIInvalidParameterLength: 1010202,
        APIInvalidParameterNonAlpha: 1010203,
        APIInvalidParameterNonNum: 1010204,
        APIInvalidParameterNonDecimal: 1010205,
        APIInvalidDate: 1010206,
        APIInvalidTime: 1010207,
        APIInvalidIPAddress: 1010208,
        APIInvalidEmailAddress: 1010209,
        APIInvalidSoftDescriptorCodeMessage: 1010301,
        APINoRouteToAcquirer: 1020001,
        APIUnsupportedECIDescription: 1020002,
        APIUnsupported: 1020003,

        // Validation errors
        APIUnknownOrder: 3000001,
        APIUnknownTransaction: 3000002,
        APIUnknownMerchant: 3000003,
        APIUnsupportedOperation: 3000101,
        APIUnknownIPAddress: 3000102,
        APISuspicionOfFraud: 3000201,
        APIFraudSuspicion: 3040001,
        APIUnknownToken: 3030001,
        APILuhnCheckFailed: 409,

        // Error codes relating to the Checkout Process
        APIUnsupportedCurrency: 3010001,
        APIAmountLimitExceeded: 3010002,
        APIMaxAttemptsExceeded: 3010003,
        APIDuplicateOrder: 3010004,
        APICheckoutSessionExpired: 3010005,
        APIOrderCompleted: 3010006,
        APIOrderExpired: 3010007,
        APIOrderVoided: 3010008,

        // Error codes relating to Maintenance Operations
        APIAuthorizationExpired: 3020001,
        APIAllowableAmountLimitExceeded: 3020002,
        APINotEnabled: 3020101,
        APINotAllowedCapture: 3020102,
        APINotAllowedPartialCapture: 3020103,
        APIPermissionDenied: 3020104,
        APICurrencyMismatch: 3020105,
        APIAuthorizationCompleted: 3020106,
        APINoMore: 3020107,
        APIInvalidAmount: 3020108,
        APIAmountLimitExceededCapture: 3020109,
        APIAmountLimitExceededPartialCapture: 3020110,
        APIOperationNotPermittedClosed: 3020111,
        APIOperationNotPermittedFraud: 3020112,
        APIRefundNotEnabled: 3020201,
        APIRefundNotAllowed: 3020202,
        APIPartialRefundNotAllowed: 3020203,
        APIRefundPermissionDenied: 3020204,
        APIRefundCurrencyMismatch: 3020205,
        APIAlreadyRefunded: 3020206,
        APIRefundNoMore: 3020207,
        APIRefundInvalidAmount: 3020208,
        APIRefundAmountLimitExceeded: 3020209,
        APIRefundAmountLimitExceededPartial: 3020210,
        APIOperationNotPermitted: 3020211,
        APITooLate: 3020212,
        APIReauthorizationNotEnabled: 3020301,
        APIReauthorizationNotAllowed: 3020302,
        APICannotReauthorize: 3020303,
        APIMaxLimitExceeded: 3020304,
        APIVoidNotAllowed: 3020401,
        APICannotVoid: 3020402,
        APIAuthorizationVoided: 3020403,

        // Acquirer Reason Codes
        APIDeclinedAcquirer: 4000001,
        APIDeclinedFinancialInstituion: 4000002,
        APIInsufficientFundsAccount: 4000003,
        APITechnicalProblem: 4000004,
        APICommunicationFailure: 4000005,
        APIAcquirerUnavailable: 4000006,
        APIDuplicateTransaction: 4000007,
        APIPaymentCancelledByTheCustomer: 4000008,
        APIInvalidTransaction: 4000009,
        APIPleaseCallTheAcquirerSupportCallNumber: 4000010,
        APIAuthenticationFailedPleaseRetryOrCancel: 4000011,
        APINoUIDConfiguredForThisOperation: 4000012,
        APIRefusalNoExplicitReason: 4010101,
        APIIssuerNotAvailable: 4010102,
        APIInsufficientFundsCredit: 4010103,
        APITransactionNotPermitted: 4010201,
        APIInvalidCardNumber: 4010202,
        APIUnsupportedCard: 4010203,
        APICardExpired: 4010204,
        APIExpiryDateIncorrect: 4010205,
        APICVCRequired: 4010206,
        APICVCError: 4010207,
        APIAVSFailed: 4010301,
        APIRetainCard: 4010302,
        APILostOrStolenCard: 4010303,
        APIRestrictedCard: 4010304,
        APICardLimitExceeded: 4010305,
        APICardBlacklisted: 4010306,
        APIUnauthorisedIPAddressCountry: 4010307,
        APICardnotInAuthorisersDatabase: 4010309
    }

    /**
     *
     * @param responseJSON
     * @constructor
     */
    HiPay.Token = function (responseJSON) {
        var payload;

        if (typeof responseJSON !== &#x27;undefined&#x27;) {
            payload = responseJSON;
        }
        if (typeof responseJSON.data !== &#x27;undefined&#x27;) {
            payload = responseJSON.data;
        }


        if (typeof payload === &#x27;object&#x27;) {
            _processObjectPayload(this, $.extend({}, payload, {
                token: payload.token
            }));
        } else {
            _processObjectPayload(this, $.extend({}, payload, {
                token: payload.token
            }));
        }
    };

    /**
     *
     * @constructor
     */
    HiPay.Token = function() {
        _bootstrapInstanceProperties(this);
    };

    /**
     *
     * @param context
     * @param payload
     * @returns {*}
     */
    HiPay.Token.populateProperties = function (context, payload) {
        _processObjectPayload(context, payload,  function (key, val){
            // switch (key) {
            // case &#x27;token&#x27;:
            //     break;
            // }
        });
        return context;
    };
    /**
     *
     * @param target
     */
    HiPay.setTarget = function(target) {
        HiPay.target = target;
        _initListPaymentMethod();
    };

    /**
     *
     * @returns {*}
     */
    HiPay.getTarget = function() {
        return HiPay.target;
    };

    /**
     *
     * @param username
     * @param publicKey
     */
    HiPay.setCredentials = function(username, publicKey) {
        HiPay.username = username;
        HiPay.publicKey = publicKey;

        _initListPaymentMethod();
    };


    var _availablePaymentProductsCustomerCountry = &quot;&quot;;
    var _availablePaymentProductsCurrency = &quot;&quot;;

    var _customPaymentProducts = [];
    // var _availablePaymentProductsCodeCollection = [&quot;cb&quot;, &quot;visa&quot;, &quot;mastercard&quot;, &quot;american-express&quot;, &quot;carte-accord&quot;, &quot;bcmc&quot;, &quot;maestro&quot;, &quot;postfinance-card&quot;, &quot;bcmc-mobile&quot;, &quot;dexia-directnet&quot;, &quot;giropay&quot;, &quot;ideal&quot;, &quot;ing-homepay&quot;, &quot;sofort-uberweisung&quot;, &quot;sisal&quot;, &quot;sdd&quot;, &quot;paypal&quot;, &quot;yandex&quot;, &quot;payulatam&quot;, &quot;paysafecard&quot;];
    var _availablePaymentProductsCollection = [];
    var _availableAndEnabledPaymentProductsCollection = [];

    HiPay.setAvailalblePaymentProductsCustomerCountry = function(countryISO2) {
        _availablePaymentProductsCustomerCountry = countryISO2;
        _initListPaymentMethod();
    }

    HiPay.setAvailalblePaymentProductsCurrency = function(currency) {
        _availablePaymentProductsCurrency = currency;
        _initListPaymentMethod();
    }

    HiPay.enabledPaymentProducts = function(collectionPaymentProducts) {
        _customPaymentProducts = collectionPaymentProducts;
        _initListPaymentMethod();
    }

    // HiPay.getFormCC = function(containerId) {
    //
    //     var containerHtml = document.getElementById(containerId);
    //
    //
    //     if (!containerHtml) {
    //         return false;
    //     }
    //
    //     containerHtml.innerHTML += &#x27;&lt;div style=&quot;margin-top: 50px&quot;&gt;&#x27;
    //         + &#x27;&lt;div id=&quot;my-card-1&quot; class=&quot;card-js&quot; data-capture-name=&quot;true&quot; data-icon-colour=&quot;#158CBA&quot;&gt;&lt;/div&gt;&#x27;
    //         + &#x27;&lt;/div&gt;&#x27;;
    //
    // }


    // API Calls

    var _makeRequest = function(opts) {
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(opts.method, opts.url);
            xhr.onload = function () {
                if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) {
                    resolve(xhr.response);
                } else {
                    reject({
                        status: this.status,
                        statusText: xhr.statusText
                    });
                }
            };
            xhr.onerror = function () {
                reject({
                    status: this.status,
                    statusText: xhr.statusText
                });
            };
            if (opts.headers) {
                Object.keys(opts.headers).forEach(function (key) {
                    xhr.setRequestHeader(key, opts.headers[key]);
                });
            }
            var params = opts.params;
            // We&#x27;ll need to stringify if we&#x27;ve been given an object
            // If we have a string, this is skipped.
            if (params &amp;&amp; typeof params === &#x27;object&#x27;) {
                params = Object.keys(params).map(function (key) {
                    return encodeURIComponent(key) + &#x27;=&#x27; + encodeURIComponent(params[key]);
                }).join(&#x27;&amp;&#x27;);
            }
            xhr.send(params);
        });
    };


    function _disableAllInput() {
        for(var propt in _idInputMapper){
            document.getElementById(_idInputMapper[propt]).disabled = true;
        }
    }

    function _enableAllInput() {
        for(var propt in _idInputMapper){
            document.getElementById(_idInputMapper[propt]).disabled = false;
        }
    }

    /**
     *
     * @param endpoint
     * @param requestParams
     * @param returnPromise
     * @param checkKey
     * @returns {Promise}
     * @private
     */
    var _performAPICall = function (endpoint, requestParams, returnPromise, checkKey) {
        if ((typeof checkKey === &#x27;undefined&#x27; || checkKey) &amp;&amp; (typeof HiPay.publicKey === &#x27;undefined&#x27; || typeof HiPay.username === &#x27;undefined&#x27;)) {
            throw new _Error(&#x27;missing_public_key&#x27;, &#x27;You have to provide a HiPay username and public key in order to perform API calls.&#x27;);
            // {&quot;code&quot;:&#x27;+APIInvalidCardToken+&#x27;,
        }

        try{
            var authEncoded = window.btoa(HiPay.username + &#x27;:&#x27; + HiPay.publicKey);
        }catch(e) {
            throw new _Error(&#x27;missing_public_key&#x27;);
        }

        // Ne fonctionne pas avec IE 10 ?
        if (&#x27;XDomainRequest&#x27; in window &amp;&amp; window.XDomainRequest !== null &amp;&amp; isIE() != 10) {
            requestParams[&#x27;Authorization&#x27;] = &#x27;Basic &#x27; + window.btoa(HiPay.username + &#x27;:&#x27; + HiPay.publicKey);
        }

        var config = {
            headers: {
                &#x27;Authorization&#x27;: &#x27;Basic &#x27; + authEncoded,
                // &#x27;contentType&#x27;: &#x27;application/json&#x27;
                // &#x27;Accept&#x27;: &#x27;application/json&#x27;,
                // &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
                // &#x27;Accept&#x27;: &#x27;application/json, text/plain, */*&#x27;,
                // &#x27;Access-Control-Origin&#x27;: &#x27;*&#x27;,
                &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
            }
        };

        // axios.post(&quot;http://localhost:8080/example/index5.php&quot;,{key: &#x27;value&#x27;})
        //     .then(function (response) {

        //     })
        //     .catch(function (error) {

        //     });




        // if (isIE () == 8) {
        //     // IE8 code
        // } else {
        //     // Other versions IE or not IE
        // }
        //

        // if (isIE () &amp;&amp; isIE () &lt; 9) {
        //     var xdr;
        //     function err() {

        //     }
        //     function timeo() {

        //     }
        //     function loadd() {

        //     }
        //     function stopdata() {
        //         xdr.abort();
        //     }
        //
        //     xdr = new XDomainRequest();
        //     if (xdr) {
        //         xdr.onerror = err;
        //         xdr.ontimeout = timeo;
        //         xdr.onload = loadd;
        //         xdr.timeout = 10000;
        //         xdr.open(&#x27;POST&#x27;,endpoint);
        //         xdr.send(requestParams);
        //         xdr.header(config);
        //         //xdr.send(&#x27;foo=&lt;?php echo $foo; ?&gt;&#x27;); to send php variable
        //     } else {

        //     }
        // } else {
        // is IE 9 and later or not IE


        //
        // var endpoint = &#x27;https://secure2-vault.hipay-tpp.com/rest/v2/token/create.json&#x27;;
        // if (HiPay.getTarget() == &#x27;test&#x27; || HiPay.getTarget() == &#x27;stage&#x27; ) {
        //     endpoint = &#x27;https://stage-secure2-vault.hipay-tpp.com/rest/v2/token/create.json&#x27;;
        // } else if (HiPay.getTarget() == &#x27;dev&#x27;) {
        //     endpoint = &#x27;http://dev-secure2-vault.hipay-tpp.com/rest/v2/token/create.json&#x27;;
        // }
        //
        // if (!(&quot;generate_request_id&quot; in params)) {
        //     params[&#x27;generate_request_id&#x27;] = 0;
        // }











        // console.info(requestParams);
//             var createCORSRequest = function(method, url) {
//                 var xhr = new XMLHttpRequest();
//                 if (&quot;withCredentials&quot; in xhr) {

//                     // Most browsers.
//                     xhr.open(method, url, true);
//                 } else if (typeof XDomainRequest != &quot;undefined&quot;) {
//                     // IE8 &amp; IE9

//                     xhr = new XDomainRequest();
//                     xhr.open(method, url);
//                 } else {
//                     // CORS not supported.
//                     xhr = null;
//                 }
//                 return xhr;
//             };
//
//             // var url = &#x27;http://server.test-cors.org/server?id=6681318&amp;enable=true&amp;status=200&amp;credentials=false&#x27;;
//             var url = endpoint;
//             var method = &#x27;POST&#x27;;
//             var xhr = createCORSRequest(method, url);
//
//             xhr.onload = function() {
//                 // Success code goes here.
//             };
//
//             xhr.onerror = function() {
//                 // Error code goes here.
//             };
//
//             xhr.withCredentials = true;
//             xhr.send();



        // var url = &quot;127.0.0.1&quot;;
        // xObj = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
        // if(xObj!=null)
        // {
        //     xObj.open(&quot;GET&quot;, url,false);
        //     xObj.send(null);
        // }

        // if (window.XDomainRequest) {
        //     var appliance = new XDomainRequest();
        //
        //
        //     appliance.onerror = err;
        //     appliance.ontimeout = timeo;
        //     appliance.onload = loadd;
        //     appliance.timeout = 10000;
        //     appliance.open(&#x27;POST&#x27;,endpoint);
        //     appliance.send(JSON.stringify(requestParams));
        //     appliance.header(config);
        //         //xdr.send(&#x27;foo=&lt;?php echo $foo; ?&gt;&#x27;); to send php variable
        //
        //
        //
        //
        // }
        // else
//                 if (window.XMLHttpRequest) {
//                 var appliance = new XMLHttpRequest();
//
//                 appliance.onreadystatechange = function() {
//                     if (appliance.readyState === 4) {

//                         if (appliance.status === 200) {

//                             // success, use appliance.responseText
//                         } else {
//                             // error

//                         }
//                     }
//                 };
//                 appliance.open(&quot;POST&quot;, endpoint, true);
//                 // appliance.open(&quot;POST&quot;, &#x27;http://localhost&#x27;, true);
//                 appliance.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json;charset=UTF-8&quot;);
//
//
// //
//                 appliance.setRequestHeader(&#x27;Authorization&#x27;, &#x27;Basic &#x27; + authEncoded);
//                 // appliance.withCredentials = true; // to support sending cookies with CORS
//                 // requestParams = {toto : &#x27;toto&#x27;};
//                 appliance.send(JSON.stringify(requestParams));

        // }
        // else {
        //     var appliance = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
        // }


        // if (window.XMLHttpRequest) {
        //     //Firefox, Opera, IE7, and other browsers will use the native object
        //     var appliance = new XMLHttpRequest();
        // } else {
        //     //IE 5 and 6 will use the ActiveX control
        //     var appliance = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
        // }

//
//             // var appliance = new window.XMLHttpRequest();

// dump(appliance.getAllResponseHeaders());

        // return Promise(function(resolve, reject){
        //
        // });


        // return _makeRequest({
        //     method: &#x27;POST&#x27;,
        //     url: endpoint,
        //     params: requestParams,
        //     headers: config[&#x27;headers&#x27;]
        // });



        // return new Promise(function (resolve, reject) {
        //     axios.post(endpoint,requestParams,config)
        //         .then(function(responseJson) {
        //
        //             if( typeof responseJson[&#x27;code&#x27;] != &#x27;undefined&#x27; )  {
        //                 reject(new _APIError(responseJson));
        //             }
        //             else {
        //                 console.log(&quot;responseJson&quot;);
        //                 console.log(responseJson);
        //                 var cardToken = new HiPay.Token(responseJson);
        //                 cardToken.constructor.populateProperties(cardToken, responseJson.data);
        //                 resolve(cardToken);
        //             }
        //         }).catch(function (error) {
        //         reject(new _APIError(error));
        //
        //
        //
        //
        //
        //
        //
        //
        //
        //         // var appliance = new window.XDomainRequest();
        //         // appliance.onload = function() {
        //         //     // do something with appliance.responseText
        //         // };
        //         // appliance.onerror = function() {
        //         //     // error handling
        //         // };
        //         //
        //         // // (endpoint,requestParams,config
        //         // appliance.open(&quot;POST&quot;, endpoint, true);
        //         // appliance.send(requestParams);
        //
        //
        //         // returnPromise.reject(new _APIError(error));
        //     });
        // });







        return new Promise(function (resolve, reject) {

            fetch(endpoint, {
                method: &#x27;POST&#x27;,
                headers: config[&#x27;headers&#x27;],
                body: JSON.stringify( requestParams )
            })
                .then(function (response) {
                    // alert(response);
                    return response.json();
                })
                .then(function (result) {
                    if( typeof result[&#x27;code&#x27;] != &#x27;undefined&#x27; )  {
                        reject(new _APIError(result));
                    }
                    else {
                        var cardToken = new HiPay.Token(result);
                        cardToken.constructor.populateProperties(cardToken,result);
                        _disableAllInput();
                        resolve(cardToken);

                    }

                })
                .catch(function (error) {
                    // retry call
                    fetch(endpoint, {
                        method: &#x27;POST&#x27;,
                        headers: config[&#x27;headers&#x27;],
                        body: JSON.stringify( requestParams )
                    })
                        .then(function (response) {
                            return response.json();
                        })
                        .then(function (result) {
                            if( typeof result[&#x27;code&#x27;] != &#x27;undefined&#x27; )  {
                                reject(new _APIError(result));
                            }
                            else {
                                var cardToken = new HiPay.Token(result);
                                cardToken.constructor.populateProperties(cardToken,result);
                                _disableAllInput();
                                resolve(cardToken);

                            }

                        })
                        .catch(function (error) {
                            reject(new _APIError(error));

                        });

                });

        });

    };


var _initAvailableAndEnabledPaymentProductsCollection = function() {
    var _listEnabledPaymentProducts = [];
    _availableAndEnabledPaymentProductsCollection = [];

    if (_availablePaymentProductsCollection.length &gt; 0) {
        if (_customPaymentProducts.length &gt; 0) {
            for (productAvailableIndex in _availablePaymentProductsCollection) {

                for (productCustomIndex in _customPaymentProducts) {

                    if (_customPaymentProducts[productCustomIndex] == _availablePaymentProductsCollection[productAvailableIndex][&#x27;code&#x27;]) {
                        _availableAndEnabledPaymentProductsCollection.push(_availablePaymentProductsCollection[productAvailableIndex][&#x27;code&#x27;]);
                    }
                }

            }
        } else {
            for (productAvailableIndex in _availablePaymentProductsCollection) {
                _availableAndEnabledPaymentProductsCollection.push(_availablePaymentProductsCollection[productAvailableIndex][&#x27;code&#x27;]);
            }

        }
    }
    // return _availableAndEnabledPaymentProductsCollection;


};



var _getAvailablePaymentProducts = function() {


    if (!HiPay.getTarget() || !HiPay.username || !HiPay.publicKey || !_availablePaymentProductsCustomerCountry || !_availablePaymentProductsCurrency) {
        return;
    }

    var endpoint = _endPointAvailablePaymentProducts[&#x27;prod&#x27;];
    if (HiPay.getTarget() == &#x27;test&#x27; || HiPay.getTarget() == &#x27;stage&#x27; ) {
        endpoint = _endPointAvailablePaymentProducts[&#x27;stage&#x27;];
    } else if (HiPay.getTarget() == &#x27;dev&#x27;) {
        endpoint = &#x27;http://localhost:8080/example/dev-api-token.php&#x27;;
    }

    // endpoint = endpoint + &quot;?eci=7&amp;payment_product=visa&amp;payment_product_category_list=credit-card&amp;customer_country=FR&amp;currency=EUR&quot;;
    endpoint = endpoint + &quot;?eci=7&amp;customer_country=&quot;+_availablePaymentProductsCustomerCountry+&quot;&amp;currency=&quot; + _availablePaymentProductsCurrency;
    // endpoint = endpoint + &quot;accept_url=hipay%3A%2F%2Fhipay-fullservice%2Fgateway%2Forders%2FDEMO_59f08c099ca87%2Faccept&amp;amount=60.0&amp;authentication_indicator=0&amp;cancel_url=hipay%3A%2F%2Fhipay-fullservice%2Fgateway%2Forders%2FDEMO_59f08c099ca87%2Fcancel&amp;city=Paris&amp;country=FR&amp;currency=EUR&amp;decline_url=hipay%3A%2F%2Fhipay-fullservice%2Fgateway%2Forders%2FDEMO_59f08c099ca87%2Fdecline&amp;description=Un%20beau%20v%C3%AAtement.&amp;display_selector=0&amp;eci=7&amp;email=client%40domain.com&amp;exception_url=hipay%3A%2F%2Fhipay-fullservice%2Fgateway%2Forders%2FDEMO_59f08c099ca87%2Fexception&amp;firstname=Martin&amp;gender=U&amp;language=en_US&amp;lastname=Dupont&amp;long_description=Un%20tr%C3%A8s%20beau%20v%C3%AAtement%20en%20soie%20de%20couleur%20bleue.&amp;multi_use=1&amp;orderid=DEMO_59f08c099ca87&amp;payment_product_category_list=ewallet%2Cdebit-card%2Crealtime-banking%2Ccredit-card&amp;pending_url=hipay%3A%2F%2Fhipay-fullservice%2Fgateway%2Forders%2FDEMO_59f08c099ca87%2Fpending&amp;recipientinfo=Employee&amp;shipping=1.56&amp;state=France&amp;streetaddress2=Immeuble%20de%20droite&amp;streetaddress=6%20Place%20du%20Colonel%20Bourgoin&amp;tax=2.67&amp;zipcode=75012&quot;;
    try{
        var authEncoded = window.btoa(HiPay.username+&#x27;:&#x27;+HiPay.publicKey);
    }catch(e) {
        throw new _Error(&#x27;missing_public_key&#x27;);
    }

    var config = {
        headers: {
            &#x27;Authorization&#x27;: &#x27;Basic &#x27; + authEncoded,
            // &#x27;contentType&#x27;: &#x27;application/json&#x27;
            // &#x27;Accept&#x27;: &#x27;application/json&#x27;,
            // &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
            &#x27;Accept&#x27;: &#x27;application/json&#x27;
            // &#x27;Access-Control-Origin&#x27;: &#x27;*&#x27;,
            // &#x27;Content-Type&#x27;: &#x27;application/json&#x27;
        }
    };


    // var requestParams = {
    //     &#x27;currency&#x27; : &quot;EUR&quot;
    // };

    _loadPaymentProduct = true;

    return fetch(endpoint, {
        method: &#x27;GET&#x27;,
        headers: config[&#x27;headers&#x27;]
        // body: JSON.stringify( requestParams )
    }).then(function (response) {

        return response.json();
    }).then(function (availablePaymentProductsCollection) {
        _availablePaymentProductsCollection = availablePaymentProductsCollection;
        _loadPaymentProduct = false;
    })
        .catch(function (error) {
            _loadPaymentProduct = false;
            reject(new _APIError(error));

        });


};

    var _initListPaymentMethod = function() {
        _getAvailablePaymentProducts();






    };


    /**
     *
     * @param data
     * @private
     */
    var _APIError = function (data) {

        var payload;


        // dump(data.response.data);
        if (typeof data.response.data !== &#x27;undefined&#x27;) {
            payload = data.response.data;
        }

        if (typeof payload === &#x27;object&#x27;) {
            _processObjectPayload(this, $.extend({}, payload, {
                code: payload.code,
                message: payload.message,
                description: payload.description,
            }));
        } else {
            _processObjectPayload(this, $.extend({}, payload, {
                code: &#x27;code&#x27;,
                message: &#x27;other&#x27;,
                description: &#x27;description&#x27;
            }));
        }
    };

    _APIError.prototype = new _Error();

    /**
     *
     * @param code
     * @param message
     * @private
     */

    // var _InvalidParametersError = function (code, message)
    function _InvalidParametersError(code, message)
    {
        _processObjectPayload(this, {
            type: &#x27;invalid_parameters&#x27;,
            code: code,
            message: message
        });
    };

    _InvalidParametersError.prototype = new _Error();


    /**
     *
     * @param errorCollection
     * @private
     */
    var _InvalidFormTokenizationError = function (errorCollection) {
        _processObjectPayload(this, {
            type: &#x27;invalid_cc_form&#x27;,
            errorCollection: errorCollection
        });
    };

    _InvalidFormTokenizationError.prototype = new _Error();


    _defineProperties(HiPay.Token, {
        token: {name: &#x27;token&#x27;},
        requestId: {name: &#x27;request_id&#x27;},
        brand: {name: &#x27;brand&#x27;},
        pan: {name: &#x27;pan&#x27;},
        cardHolder: {name: &#x27;card_holder&#x27;},
        cardExpiryMonth: {name: &#x27;card_expiry_month&#x27;},
        cardExpiryYear: {name: &#x27;card_expiry_year&#x27;},
        issuer: {name: &#x27;issuer&#x27;},
        country: {name: &#x27;country&#x27;},
        cardType: {name: &#x27;card_type&#x27;}
    });



    _defineProperties(_APIError, {
        code: {name: &#x27;code&#x27;},
        message: {name: &#x27;message&#x27;},

    });


    _defineProperties(_InvalidParametersError, {
        code: {name: &#x27;code&#x27;},
        message: {name: &#x27;message&#x27;},
        server_response: {name: &#x27;serverResponse&#x27;}
    });


    _defineProperties(_InvalidFormTokenizationError, {
        code: {name: &#x27;code&#x27;},
        message: {name: &#x27;message&#x27;},
        errorCollection: {name: &#x27;errorCollection&#x27;},
        server_response: {name: &#x27;serverResponse&#x27;}
    });

    /**
     * Get a token with credit card information.
     *
     * @method HiPay.tokenize
     * @param {String} cardNumber
     * @param {String} expiryMonth
     * @param {String} expiryYear
     * @param {String} cardHolder
     * @param {String} cvv
     * @param {Boolean} multiUse
     * @param {Boolean} generateRequestId
     *
     */
    HiPay.tokenize = function(cardNumber, expiryMonth, expiryYear, cardHolder, cvv, multiUse, generateRequestId) {


        var params = {
            card_expiry_month: expiryMonth,
            card_expiry_year: expiryYear,
            card_number: cardNumber,
            card_holder: cardHolder,
            cvc: cvv,
            multi_use: multiUse,
            generate_request_id: generateRequestId
        }


        var returnPromise = Promise;
        if(!_isBrowser()) {
            return returnPromise.reject(new _APIError(&#x27;&quot;message&quot; : &quot;cant tokenize on server side&quot;}&#x27;));
        }

        if(params[&#x27;card_expiry_month&#x27;].length &lt; 2) {
            params[&#x27;card_expiry_month&#x27;] = &#x27;0&#x27; + params[&#x27;card_expiry_month&#x27;];
        }
        if( params[&#x27;card_expiry_year&#x27;].length == 2) {
            params[&#x27;card_expiry_year&#x27;]  = &#x27;20&#x27; +  params[&#x27;card_expiry_year&#x27;];
        }
        // var errorCollection = _isValidCCForm(params);

        var validatorCreditCard = _instanceServiceCreditCard.validatorCreditCard();

        // var errorCollection = _isValidCCForm(params);

        // if (errorCollection.length &gt; 0) {


        if (validatorCreditCard.isValid(params) === false) {
            // var errorCollection = _isValidCCForm(params);
            var errorCollection = validatorCreditCard.errorCollection;


            // var customError = new Error(&#x27;Form error&#x27;);
            var customError = new _InvalidFormTokenizationError(errorCollection);
            customError.errorCollection = errorCollection;
            return Promise.reject(customError);
        }

        else {
            var endpoint = _endPointTokenize[&#x27;prod&#x27;];
            if (HiPay.getTarget() == &#x27;test&#x27; || HiPay.getTarget() == &#x27;stage&#x27; ) {
                endpoint = _endPointTokenize[&#x27;stage&#x27;];
            } else if (HiPay.getTarget() == &#x27;dev&#x27;) {
                endpoint = &#x27;http://localhost:8080/example/dev-api-token.php&#x27;;
            }

            if (!params[&#x27;generate_request_id&#x27;]) {
                params[&#x27;generate_request_id&#x27;] = 0;
            }

            if (!params[&#x27;multi_use&#x27;]) {
                params[&#x27;multi_use&#x27;] = 0;
            }

            var config = {
                headers: {&#x27;Authorization&#x27;: &#x27;Basic &#x27; + window.btoa(HiPay.username + &#x27;:&#x27; + HiPay.publicKey)}
            };

            return _performAPICall(endpoint, params, returnPromise);
        }
    };

    /**
     *
     * @param localeString
     */
    HiPay.Form.setLocale = function(localeString) {
        HiPay.Form.locale = localeString;

    };


    /**
     * Helper to display CVV information
     * @method HiPay.Form.CVVHelpText
     */
    HiPay.Form.CVVHelpText = function() {

        var serviceCreditCard = new _serviceCreditCard();
        var CVVLength = serviceCreditCard.getCreditCardCVVLengthMax();
        if (CVVLength == undefined) {
            CVVLength = 3;
        }
        return _translationJSON[HiPay.Form.locale][&quot;FORM_CVV_&quot;+CVVLength+&quot;_HELP_MESSAGE&quot;];

    };

    /**
     * Tokenize form data.
     * @method HiPay.Form.tokenizePaymentFormData
     */

    HiPay.Form.tokenizePaymentFormData = function() {

        if (!HiPay.Form.paymentFormDataIsValid()) {
            return false;
        }

        var creditCardExpiryDate = document.getElementById(_idInputMapper.cardExpiryDate).value;
        var explodeExpiryDate = creditCardExpiryDate.split(_separatorMonthYear);
        var month = explodeExpiryDate[0];
        var year = &quot;20&quot;+explodeExpiryDate[1];
        var params = {
            card_number: document.getElementById(_idInputMapper.cardNumber).value,
            card_expiry_month: month,
            card_expiry_year: year,
            card_holder: document.getElementById(_idInputMapper.cardHolder).value,
            cvv: document.getElementById(_idInputMapper.cardCVV).value,
            multi_use: &#x27;0&#x27;,
            generate_request_id: &#x27;0&#x27;
        };
        return HiPay.tokenize(params[&#x27;card_number&#x27;], params[&#x27;card_expiry_month&#x27;], params[&#x27;card_expiry_year&#x27;], params[&#x27;card_holder&#x27;], params[&#x27;cvv&#x27;], params[&#x27;multi_use&#x27;], params[&#x27;generate_request_id&#x27;] )
//

    }


    return HiPay;

} (HiPay || {}));
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
